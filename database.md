# 용어
- 튜플 = 레코드 = 행
- 애트리뷰트 = 속성 = 열
- 엔티티 = 릴레이션 = 테이블

# 데이터베이스 설계 단계
개념(ERD) -> 논리(정규화) -> 물리(반정규화)
## 개념 단계
- ER 다이어그램
- 데이터 요소 관게 표현
요구사항 명세서를 E-R 다이어그램화
## 논리 단계
- 정규화(트랜잭션 인터페이스 설계)
- 스키마 설계
## 물리 단계
- 속성들의 자료형, 크기 등 설계
- 레코드 집중의 분석 및 설계
- 실제 저장 구조 정의
- 성능 향상이 필요하다면 반정규화

# 키
#### 슈퍼 키(Super key)
테이블에서 각 행을 유일하게 식별 가능한 하나 이상의 속성들의 집합 (유일성)
#### 후보 키(Candidate key)
각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합
(슈퍼 키중 최소한의 속성들의 집합) (최소성)
#### 기본 키(primary key)
- 후보 키중 선택한 키 하나, 최소성과 유일성 만족
- NULL값을 가질 수 없고 중복값도 안됨(`개체 무결성`)
#### 대체 키(alternate key)
선택받지 못한 기본 키

# 정규화
- 삽입이상, 갱신이상, 삭제이상 등의 anomaly을 없애기 위함
- 부분함수종속, 이행적함수종속을 완전함수종속으로 변환
- 논리적 설계 단계에서 진행

## 함수종속관계
|함수종속|뜻|정규화|
|부분|기본키가 복합키이고, 기본키 구성원 중 일부에게 종속될 경우|기본키 중 종속된 일부와 나머지를 분리|
|이행적|X->Y->Z 라면 X->Z일때|X->Y, Y->Z로 분리|
|완전|값이 기본키에만 종속|이미 정규화가 이루어짐|

## 단계
#### 1차 정규화 (1NF)
모든 튜플을 모든 속성에 대해 원자값으로 만듦 (한 속성에 값이 단 하나만 오게끔 한 행을 여러 행으로 분리)
#### 2차 정규화 (2NF)
부분함수종속 제거
#### 3차 정규화 (3NF)
이행적함수종속 제거
#### 보이스/코드 정규화 (BCNF)
모든 결정자를 후보키로 만들어버림(후보키가 아닌 결정자를 모두 삭제)
#### 4차 정규화 (4NF)
다치종속 제거
#### 5차 정규화 (5NF)
조인 이용/제거

# 데이터 무결성
## 제약조건
- 도메인 무결성: 필드의 무결성, 그 도메인에 들어갈 만한 값이 들어갔나
- 개체 무결성: 기본키에 NULL X, 중복값 X
- 참조 무결성: 외래키 값은 참조하는 값의 기본키 값과 동일
- 속성 무결성
- 키 무결성
- 사용자 정의 무결성

## 참조무결성 유지 옵션
참조되는 테이블에서 값 삭제시에 참조하는 테이블에선 값을 어떻게 처리할 것인가
- `CASCADE`: 행 자체 삭제
- `SET-NULL`: NULL로 값 교체
- `RESTRICTED`: 삭제하지 못하게 막음

# ER다이어그램
#### 구성요소
|요소|도형|
|---|---|
|개체|사각형|
|속성|원|
|관계|마름모|
|연결|선|

# 스키마
- 외부 스키마: 외부에서 보이는 구조
- 개념 스키마: 데이터베이스 전체적으로 관리
- 내부 스키마: 물리적인 저장장치 입장에서 DB에 저장된 것 기술
외부 스키마 -논리적 독립성- 개념 스키마 -물리적 독립성- 내부 스키마
## 뷰
- 외부 스키마
- TABLE에서 일부만 가져온 것
- 논리적으로만 존재함 (물리적으로 존재하진 않음)
- 원본이 삭제되면 뷰도 삭제
- ALTER 사용 불가, INDEX 불가

# 관계대수 연산자
#### 순수 관계 연산자
|기호|이름|연산처리|
|---|---|---|
|`σ`|SELECT|조건을 만족하는 행 출력|
|`π`|PROJECT|중복 제거하고 지정한 열만 출력|
|`▷◁`|JOIN|두 테이블에서 조건에 맞는 튜플들끼리 결합시켜 하나의 테이블로 합침|
|`÷`|DIVISION|S의 요소들이 모두 R에 포함되는 행에서 S의 요소들이 모두 빠짐|
#### 일반 관계 연산자
|기호|이름|
|---|---|
|`∪`|합집합|
|`∩`|교집합|
|`-`|차집합|
|`×`|카디션 프로덕트|

# 트랜잭션의 특성
|이름|내용|
|---|---|
|영속성(`Durability`)|트랜잭션의 결과는 시스템이 고장나도 영구적으로 반영|
|독립성(`Isolation`)|트랜잭션이 실행중일때 다른 트랜잭션이 영향을 줄 수 없음|
|일관성(`Consistency`)|데이터가 일관성있게 유지|
|원자성(`Atomicity`)|전부 반영되거나 말거나(`COMMIT`, `ROLLBACK`)|

# 분산 데이터베이스 
## 파티션
테이블 또는 인덱스 등을 나눈 단위
- 데이터 엑세스 범위↓, 디스크 성능↑
- 시스템 장애 시 데이터 손상정도 최소화
- 파티션별 백업 및 복구 속도 향상
- 관리비용 증가
- 테이블 간 조인에 대한 비용 증가
## 분산 데이터베이스 목표 (Transparency)
|투명성|내용|
|---|---|
|위치(`Location`)|실제 위치 알 필요없이 논리적 명칭으로 엑세스|
|중복(`Replication`)|데이터가 여러곳에 중복되어 있어도 자동으로 그 자료에 대한 작업 수행|
|병행(`Concurrency`)|다수의 트랜잭션이 이미 실행중이어도 결과에 영향 주지 않음|
|장애(`Failure`)|장애 발생 시에도 정확히 트랜잭션이 처리됨|
- 분할(division) 투명성
- 지역사상(Local Mapping) 투명성

# SQL
## 분류(DMC)
#### 데이터 정의어(DDL) (5)
데이터 생성/수정/삭제
- CREATE
- ALTER
- DROP
- RENAME
- TRUNCATE
#### 데이터 조작어(DML) (4)
데이터 조회, 테이블의 열과 행 수정
- SELECT
- INSERT
- DELETE
- UPDATE
#### 데이터 제어어(DCL) (3)
접속 권한 수정, 무결성 유지, 병행수행 제어
- GRANT
- REVOKE
- COMMIT
#### 트랜잭션 언어(TCL) (3)
- TRANSMIT
- ROLLBACK
- SAVEPOINT

#### 추가
- trigger: 이벤트가 발생할 때마다 관련 작업이 자동으로 수행

# 로킹(Locking)
`무결성`을 위해 한 사람이 데이터를 조회 중일때 다른 사람이 조회할 수 없게 함
- 로킹 단위↑ → 공유도(병행성)↓ → 오버헤드↓

# 회복기법
### 즉시 갱신 기법
- 변경되는 내용을 `그때그때 바로` 데이터베이스에 적용
- `log`에 저장해 장애 발생시 `log`의 내용을 토대로 반복
- 장애 발생 시점에서 완료된 작업이라면 `redo`, 못했다면 `undo`
### 지연 갱신 기법
- `부분완료 될 때까지` DB에 적용 X
- 부분완료 되면 `log` 내용을 토대로 DB에 적용
- `Redo`만, `Undo` 없음
### 검사 시점 기법
- 실행 중간에 `검사 시점(check point)`를 지정해 검사 시점까지 수행 후 완료된 내용을 데이터베이스에 적용
### shadow paging 기법
- log 사용 x
- 데이터베이스를 동일한 크기의 페이지로 나눠 각 페이지마다 `복사`하여 그림자 페이지 보관
- 변경되는 내용은 원본에, 장애 발생시 그림자 페이지로 회복