# 소프트웨어 재공학
## 소프트웨어의 위기
소프트웨어 개발 속도가 하드웨어 개발 속도를 따라가질 못해 사용자의 요구사항 감당 불가능
- 프로젝트 개발 일정과 예산 측정 어려움
- 유지보수 비용 증가
- 소프트웨어 규모 증가와 복잡도에 따른 개발 비용 증가
- 프로젝트 관리 기술 부재
- 소프트웨어 개발 기술에 대한 훈련 부족

## 소프트웨어 재공학
소프트웨어의 위기를 유지보수의 생산성으로 해결
- 분석(Analysis): 기존 소프트웨어를 분석해 재공학 대상 선정
- 재구성(Restructuring): 코드를 재구성해 기존 소프트웨어 향상
- 역공학(Reverse Engineering): 기존 소프트웨어를 분석해 소스코드를 얻어냄
- 이식(Migration): 기존 소프트웨어를 다른 운영체제나 하드웨어 환경에서 사용할 수 있도록 변환
- 재사용

#### 3R
- 재공학(Reengineering)
- 재구성(Restructuring)
- 역공학(Reverse Engineering)
3R에 포함되지 않는 것: 재개발(처음부터 다시 만들기)

# 품질 관리
### 품질 분석
#### 정적분석도구
소스 코드를 실행하지 않고 코딩 표준, 코딩 스타일, 구조, 의존관계 분석
- PMD
- SonarQube
- Find Bug
- Checkstyle
- cppcheck
- corbertuna


# 테스트
Brooks의 법칙: 오류의 80%는 전체 모듈의 20% 내에서 발견된다
#### White Box Testing
- 모든 문장을 수행하며 논리적 경로 점검, 내부 작동 직접 관찰
- 개발자 관점

종류
- 문장검증
- 선택검증
- 경로검증
- 조건검증

#### Black Box Testing
- 사용자 관점

종류
- 동등 분할 기법: 모든 집합에 대해 대표값 넣어보기
- 경계값 분석 기법: 경계값-1, 경계값, 경계값+1 넣어보기
- 오류 예측 기법
- 원인 결과 그래프 기법
- 의사결정 테이블 테스팅
- 상태 전이 테스팅

## V모델 테스팅
폭포수개발 모델에서 사용

단위테스트 -> 통합테스트 -> 시스템테스트 -> 인수테스트
### 단위 테스트
모듈 당 테스트
- 정적 테스트
- 동적 테스트
### 통합 테스트
- 상향식 통합: 하위 모듈부터, 공백이 있으면 드라이버로 대체
- 하향식 통합: 메인 모듈부터, 공백이 있다면 스텁으로 대체
- 빅뱅: 한번에 테스트, 작아야 가능
- 백본: 상향식 + 하향식
### 시스템 테스트
실제로 운영되는 시스템 서버에서 테스트
- 기능: 소프트웨어의 기능, 사용자의 요구사항 만족
- 비기능: 성능 & 보안
### 인수 테스트
사용자가 테스트 진행
- 알파 테스트: 사용자 + 개발진
- 베타 테스트: 사용자만

# 국제 표준
### 소프트웨어 품질 표준
#### ISO/IEC 9126
- 기능성: 요구사항을 얼마나 잘 만족하는가
- 신뢰성: 장애 없이 얼마나 잘 수행하나
- 사용성: 이해하고, 학습하고, 사용하기 편한 정도
- 효율성: 자원을 얼마나 효율적으로 쓰나
- 유지보수성: 수정이 얼마나 쉽나
- 이식성: 다른 환경으로 이전되기 얼마나 쉽나

#### ISO/IEC 25010, SQuaRE
가장 최근 품질특성
- 정확성: 사용자의 요구사항을 얼마나 잘 만족하는가
- 신뢰성: 기능상의 장애 없이 의도한 임무를 얼마나 잘 수행하나
- 효율성: 시스템 자원과 코드량의 최적화
- 무결성: 인가된 사용자만이 자료에 접근 가능
- 사용 용이성: 프로그램을 배우는 데 요구되는 노력이 최소일 것
- 유지 보수성: 프로그램의 오류를 발견하고 수정하는데 드는 노력 최소화
- 이식성: 다른 환경으로 이전하는데 요구되는 노력
- 재사용성: 소프트웨어 일부를 다른 시스템에서 재사용

### 패키지 소프트웨어
#### ISO/IEC 12119
패키지 소프트웨어 품질 요구사항, 테스트 방법 규정
|속성|내용|
|제품설명서|소프트웨어 패키지의 속성 설명|
|사용자문서|사용 가능한 전체 문서들의 집합|
|실행프로그램|요구사항이 명확하게 정의된 대상|

### 프로세스
#### ISO/IEC 12207
|생명주기 프로세스|내용|
|---|---|
|기본|획득,공급,개발,운영,유지보수|
|지원|문서화,형상관리,품질보증,검증,확인,합동검토,감사,문제해결|
|조직|관리,기반구조,개선,교육훈련|

- 기본: 기본적인 개발 프로세스
- 지원: 기본 생명주기를 지원하는 프로세스
- 조직: 조직 차원에서 지원하는 프로세스

#### ISO/IEC 15504(SPICE)
|단계|내용|
|불안정(Incomplete)|미구현, 목표 미달성|
|수행(Performed)|프로세스 수행 및 목적 달성|
|관리(Managed)|프로세스 수행 계획 및 관리|
|확립(Established)|`표준 프로세스`의 사용|
|예측(Predictable)|프로세스의 `정량적 이해` 및 통제|
|최적화(Optimizing)|프로세스의 `지속적`인 개선|

# 보안
## 애플리케이션 영역
- 코드상 보안 취약점 보완
- 시큐어 코딩, 암호화

## 네트워크 영역
- 스니핑 방지, 네트워크 트래픽 암호화, 종단 간 보안
- IPSec, SSL, S-HTTP

### IPSec
- IP패킷을 보호하는 프레임워크
- ISO 7계층 중 4번째 계층의 네트워크 영역에 적용
- IPv4에 설치 필요, IPv6엔 기본 탑재

#### 기능
- 기밀성(Confidentiality)
- 무결성(Integrity)
- 송신자 인증(Origin Authentication)
- 재전송 공격 방어(Anti-replay Protection)
- 패킷 접근 제어(Access control)
- 패킷 출발지/도착지 정보 암호화(Limited Traffic Flow Confidentiality)

#### 종류
- AH(Authentication Header) 프로토콜: 무결성 보장, 인증, 위변조 방지
- ESP(Encapsulating Security Payload) 프로토콜: 암호화, 인증, 무결성
- IKE(Key Exchange) 프로토콜: 키 교환, 세션 설정

# 소프트웨어 형상 관리
개발 과정에서 발생하는 모든 변경 관리, 협업을 진행하는 멤버들의 공유 및 변경이력 관리

- `형상식별`: 형상관리 대상 구분, 관리 목록에 대한 번호 부여
- `형상통제`: SW 형상 변경 제안 검토, 변재 SW 기준선에 반영하도록 통제
- `형상감사`: SW 베이스라인의 무결성 평가 수단
- `형상기록`: SW 형상 및 변경 관리에 대한 각종 수행 기록

## 용어
- `import`: 맨 처음 프로젝트 시작 시 저장소에 등록
- `check-out`: 저장소에서 소스를 찾아오는 명령
- `check-in`(=`commit`): 수정한 파일을 저장소에 저장해 갱신
-  `add`: 새 파일을 관리 파일로 추가
- `update`: 저장소에 변경된 내용을 로컬로 반영
- `diff`: 소스를 비교하는 명령
- `merging`: 충돌된 파일을 합치는 명령

## 도구
- CVS
- SVN
- GIT

# 인터페이스 구현 
## 비동기 통신기술
AJAX - `javascript`

## 검증도구
- xUnit - 다양한 언어 지원
- STAF - `서비스 호출`, `컴포넌트 재사용`
- FitNesse - `웹 기반`
- Watir - `Ruby` 기반
- Selenium - `웹 어플리케이션` 테스트 프레임워크

# EAI(Enterprise Application Integration)
조직의 애플리케이션을 연결해 업무 프로세스 단순화 및 자동화

`정보 전달`, `연계`, `통합`을 가능하게 해주는 솔루션

#### 구축유형
- Point-to-Point: 미들웨어 없이 1:1 방식으로 애플리케이션 연결
- hub-and-spoke: Hub를 미들웨어로, hub 한개만 사용
- message-bus
- hybrid: message-bus와 hub-and-spoke 혼합

# 알고리즘
## 알고리즘 설계 기법
#### 분할정복법(divide and conquer)
- 병합정렬
- 2진탐색
#### 동적계획법(dynamic programming)
- 플로이드
#### 탐욕법(greedy)
- Dijkstra
#### 백트래킹법(backtracking)
- DFS 알고리즘
#### 근사해법(approximation)
최적해에 가까운 근사해 찾기

## 정렬 알고리즘
#### 시간복잡도 O(n^2)
- 삽입정렬: (i)pass에서 i번째 원소와 그 앞 원소 비교
- 버블정렬: 가장 뒷 자리부터 정렬
- 선택정렬: 가장 앞 자리부터 정렬

#### 시간복잡고 O(nlogn)
- 퀵정렬
- 힙정렬: 힙을 만들어 정렬, 최대 힙 트리
- 병합정렬

## 트리 순회
#### 전위 순회
목표 노드의 방문은 `가장 먼저` (목표노드->오른쪽자식->왼쪽자식) ↙→
#### 중위 순회
목표 노드의 방문은 `두 자식들 사이` (오른쪽자식->목표노드->왼쪽자식) ↗↘
#### 후위 순회
목표 노드의 방문은 `가장 나중` (오른쪽자식->왼쪽자식->목표노드)→↖


# 반정규화
성능개선을 위해 정규화를 역행

- 테이블 분할
  - 수평 분할: 값을 기준으로 두 테이블로 분할
  - 수직 분할: 테이블의 속성을 분할해 두 테이블로 분할
- 테이블 중복
- 통계(집계) 테이블 추가
- 진행 테이블 추가
- 컬럼 중복
- 파생 컬럼 추가

# 디지털 저작권 관리(DRM)
|이름|내용|
|---|---|
|암호화|콘텐츠 및 라이선스 암호화|
|키관리|암호화한 키에 대한 저장 및 배포|
|식별기술|콘텐츠에 대한 식별체계 표현 기술|
|정책 관리|라이선스 발급 및 사용에 대한 정책표현|
|크랙 방지|크랙에 의한 콘텐츠 사용방지 기술|
|인증|라이선스 발급 및 사용의 기준이 되는 인증기술|
|인터페이스|상이한 DRM 플랫폼 간의 상호 호환성 인터페이스|
|사용권한|콘텐츠의 사용에 대한 권한 관리|

# SW 패키징 도구
## 고려사항
- 암호화/보안
- 다양한 기종 연동
- 사용자 편의성을 위한 복잡성, 비효율성 문제
- 암호화 알고리즘
- 지속적인 배포

# 클린 코드
## 작성 원칙
- 가독성: 이해하기 쉬운 용어
- 단순성: 한번에 한가지 처리만 진행
- 의존성: 코드의 변경이 다른 부분에 영향을 적게 주게 작성됨
- 중복성: 중복된 코드 제거, 공통된 코드에서 사용
- 추상화: 상세 내용은 하위 클래스에서 구현

#### 외계인 코드(Alien code)
아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 프로그램
~~젤나가~~ ~~로스트 테크놀로지~~

# DB
### 파티션
테이블 또는 인덱스 등을 나눈 단위
- 데이터 엑세스 범위↓, 디스크 성능↑
- 시스템 장애 시 데이터 손상정도 최소화
- 파티션별 백업 및 복구 속도 향상
- 관리비용 증가
- 테이블 간 조인에 대한 비용 증가