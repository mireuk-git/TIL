# Codekata
### 4466
[link](https://www.acmicpc.net/problem/4466)
#### python
<b>1st try:</b>

```python
import sys
input=sys.stdin.readline

def evaluate(expr):
    stack=[]
    i=0
    while i < len(expr):
        if expr[i] == '(': stack.append(i+1)
        if expr[i] == ')':
            expr=expr[:stack[-1]-1]+evaluate_sub(expr[stack[-1]:i])+expr[i+1:]
            i=stack[-1]-1
            del stack[-1]
        i+=1
    if len(expr)==1: return expr
    return evaluate_sub(expr)

def evaluate_sub(expr):
    while '!' in expr:
        i=expr.find("!")
        if expr[i+1]=='t': expr=expr[:i]+'f'+expr[i+2:]
        else: expr=expr[:i]+'t'+expr[i+2:]
        
    if len(expr)==1: return expr

    if expr[1]=='|':
        if expr[0]=='t' or expr[2]=='t': return 't'
        else: return 'f'
    elif expr[1]=='&':
        if expr[0]=='t' and expr[2]=='t': return 't'
        else: return 'f'


x=int(input().strip())
for test_case in range(1,x+1):
    expr,expected=input().strip().split(" = ")
    eval_result = evaluate(expr)
    if eval_result == expected: result = "Good"
    else: result = "Bad"
    print(f"{test_case}: {result} brain")
```
- 대괄호로 구분된 연산순서를 스택으로 관리해(괄호 시작 부분을 스택에 저장) 순서대로 연산하며 처리
- `not(!)` 연산은 괄호로 감싸지지 않아 수식에 `!`가 포함되어 있다면 우선적으로 처리하는 과정 필요
- 구조적으로 괄호에 연산이 한번씩 포함되어 있지 않다면 연산이 제대로 이루어지지 않음

<b>2nd try:</b>

```python
import re

# 연산자: (우선순위, 결합방향, 피연산자 수)
OPS = {
    '!': (3, 'R', 1),
    '&': (2, 'L', 2),
    '|': (1, 'L', 2),
}

def tokenize(s: str):
    # t, f, !, &, |, (, ) 만 허용
    token_spec = [
        (r't', ('LIT', True)),
        (r'f', ('LIT', False)),
        (r'!', ('!', '!')),
        (r'&', ('&', '&')),
        (r'\|', ('|', '|')),
        (r'\(', ('(', '(')),
        (r'\)', (')', ')')),
        (r'\s+', None),  # 공백 스킵
    ]
    tokens = []
    idx = 0
    while idx < len(s):
        matched = False
        for pattern, tok in token_spec:
            m = re.match(pattern, s[idx:])
            if m:
                matched = True
                if tok is not None:
                    tok_type, tok_val = tok
                    tokens.append((tok_type, tok_val))
                idx += len(m.group(0))
                break
        if not matched:
            raise ValueError(f"잘못된 문자: {s[idx]}")
    return tokens


def to_rpn(tokens):
    output = []
    stack = []
    for tok_type, tok_val in tokens:
        if tok_type == 'LIT':
            output.append((tok_type, tok_val))
        elif tok_type == '(':
            stack.append(('(', '('))
        elif tok_type == ')':
            while stack and stack[-1][0] != '(':
                output.append(stack.pop())
            if not stack:
                raise ValueError("괄호 짝 오류")
            stack.pop()  # '(' 제거
        else:
            # 연산자
            prec, assoc, _ = OPS[tok_type]
            while stack and stack[-1][0] in OPS:
                top = stack[-1][0]
                top_prec, top_assoc, _ = OPS[top]
                if (assoc == 'L' and prec <= top_prec) or (assoc == 'R' and prec < top_prec):
                    output.append(stack.pop())
                else:
                    break
            stack.append((tok_type, tok_type))

    while stack:
        if stack[-1][0] in ('(', ')'):
            raise ValueError("괄호 짝 오류")
        output.append(stack.pop())
    return output


def eval_rpn(rpn):
    st = []
    for tok_type, tok_val in rpn:
        if tok_type == 'LIT':
            st.append(tok_val)
        else:
            op = tok_type
            if op == '!':
                if not st:
                    raise ValueError("단항 연산자 오류")
                st.append(not st.pop())
            else:
                if len(st) < 2:
                    raise ValueError("이항 연산자 오류")
                b = st.pop()
                a = st.pop()
                if op == '&':
                    st.append(a and b)
                elif op == '|':
                    st.append(a or b)
    if len(st) != 1:
        raise ValueError("수식 오류: 잔여 값 존재")
    return st[0]


def evaluate(expr: str) -> bool:
    return eval_rpn(to_rpn(tokenize(expr)))


if __name__ == "__main__":
    while True:
        try:
            s = input("입력: ").strip()
            if not s:
                continue
            print(evaluate(s))
        except KeyboardInterrupt:
            break
        except Exception as e:
            print("오류:", e)
```
- GPT로 작성한 코드
- 토큰화(`tokenize`), 후위표기로 전환(`to_rpn`), 연산(`eval_rpn`)의 3단계 파이프라인으로 구성
- `tokenize`: 연산자/피연산자를 분석하기 쉽게 만드는 단계
- `to_rpn`: 후위표기로 변환 - 중위표기보다 후위표기가 더 연산하는데 편리함(우선순위가 계산하기 더 편함)
- `eval_rpn`: 후위표현을 스택 기반으로 연산
