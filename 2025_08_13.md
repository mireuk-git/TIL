# CodeKata
### python
#### 5679
[link](https://www.acmicpc.net/problem/5679)
```python
h=int(input())
while h!=0:
    mh=h
    while h>1:
        if h%2:
            h=h*3+1
            if h>mh: mh=h
        else: h//=2
    print(mh)
    h=int(input())
```
- `mh`: 최대 h
- 처음엔 mh를 0으로 두고 계산을 시작했는데 초기값이 최대값일 가능성을 염두에 두지 않은 초기최대값이다. `mh`의 초기값은 h0으로 하는게 맞다. 

#### 2596
[link](https://www.acmicpc.net/problem/2596)
```python
code=['000000','001111','010011','011100','100110','101001','110101','111010']
char=['A','B','C','D','E','F','G','H']
n=int(input())
message=input()
decoded=''
decode_fail=True
for i in range(n):
    decode_fail=True
    for j in range(len(code)):
        if sum(ch1==ch2 for ch1,ch2 in zip(code[j],message[6*i:6*(i+1)]))>=5:
            decoded+=char[j]
            decode_fail=False
            break
    if decode_fail: break

if decode_fail: print(i+1)
else: print(decoded)
```
- `code`와 `char`에 같은 순서대로 데이터를 기입, 즉 `code[i]`와 `char[i]`끼리 페어링된다
- `message`: 입력받는 메시지, 디코딩 대상
- `decoded`: 디코딩된 문자 하나하나 누적해 메시지를 번역, 즉 print시점에선 번역된 메시지
- `message`에서 슬라이싱으로 6자씩 끊어 디코딩 진행, `code`에서 비트 하나씩 비교해 그 차이가 1개 이하이면 `char`에서 해당하는 문자 하나를 꺼내 `decode`에 누적시킴
- 디코딩 과정 중에 차이가 1개 이하인 `code`를 찾지 못했다면 디코딩 실패로 간주, 즉시 디코딩 작업 중단하고 해당 index 반환
