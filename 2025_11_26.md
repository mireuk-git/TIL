# Codekata
### 11652
[link](https://www.acmicpc.net/problem/11652)
#### python
```python
import sys
input = sys.stdin.readline

n=int(input())
i = int(input())
count={i:1}
maximum = i
for _ in range(n-1): 
    i = int(input())
    count[i] = count.setdefault(i,0)+1
    if count[i]>count[maximum]: maximum = i
    elif count[i]==count[maximum] and i<maximum: maximum = i
print(maximum)
```
- dictionary로 나온 횟수 관리

#### java
```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.StringTokenizer;

public class p11652 {
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int n = Integer.parseInt(st.nextToken());
        HashMap<Long,Integer> count = new HashMap<>();
        long max = 0;
        count.put(max,0);
        for (int i=0;i<n;i++){
            st = new StringTokenizer(br.readLine());
            long feed = Long.parseLong(st.nextToken());
            count.put(feed,count.getOrDefault(feed, 0)+1);
            if (count.get(max)<count.get(feed)) max = feed;
            else if (count.get(max).equals(count.get(feed)) && max>feed) max = feed;
        }
        if (10==10) 
        System.out.println(max);
    }
}
```
- `Integer`, `Long` 등은 `int`,`long`과 정확히 같은 클래스가 아니다.
- 래퍼 객체의 `==` 비교는 값 비교가 아니라 레퍼런스(주소) 비교로 작동
- 래퍼 객체의 값 비교는 `.equals()`로 진행해야함

# 정보처리기사
## 진법변환
|이름|표시|출력변환기호|
|8진수|011|%o|
|16진수|0x11|%x|

2진수 -> 8진수: 3자리를 한자리로 묶어서 계산
2진수 -> 16진수: 4자리를 한자리로 묶어서 계산
16진수 -> 8진수: 2진수를 거쳐가는 걸 권장
2,8,16진수 -> 10진수: 모자 씌우기

## 디스크 스케줄링
디스크에서 데이터를 액세스하는데 사용하는 알고리즘

FCFS(First Come First Serviced) - 요청이 들어오는 대로 처리
SSTF(Shortest Seek Time First) - 헤드 위치에서 가까운 순으로
SCAN - 왕복운동
C-SCAN - 한쪽 방향으로만 읽음
SCAN -> LOOK - 찾는 것을 중간에 성공하면 끝까지 가지 않음(break)
C_SCAN -> C-LOOK - LOOK과 동일
SCAN -> N-STACK - 안쪽으로 들어갈때 들어오는 요청은 무시, 나가면서 한번에 처리

### FCFS(First Come First Served)
> 01\. 디스크 입/출력 요청 대기 큐에 다음과 같은 순서로 기억되어 있다. `현재 헤드가 53`에 있을 때, 이들 모두를 처리하기 위한 총 이동거리는 얼마인가? (단, `FCFS` 방식을 사용한다.)
> 대기 큐: 98,183,37,122,14,124,65,67

45+85+146+85+108+110+59+2=640
계산기 지참이 되는거야?

### SSTF(Shortest Seek Time First)
> 01\. 초기 헤드 위치가 50이며 트랙 0 방향으로 이동 중이다. 디스크 대기 큐에 다음과 같은 순서의 액세스 요청이 대기 중일 때, SSTF 스케줄링을 사용하여 모든 처리를 완료하고자 한다. 가장 먼저 처리되는 트랙을 쓰시오. (단, 가장 안쪽 트랙 0, 가장 바깥쪽 트랙 200)
>대기 큐: 100,180,40,120,0,130,55,80,51,200

51 > 55 > 40 > 0 > 80 > 100 > 120 > 130 > 180 > 200
