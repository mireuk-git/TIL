# Codekata
### 4635
#### python
```python
n=int(input())
while n!=-1:
    distance=0
    prev_t=0
    for i in range(n):
        s,t=map(int,input().split())
        distance+=s*(t-prev_t)
        prev_t=t
    print(f"{distance} miles")
    n=int(input())
```
#### java
```java
import java.util.Scanner;

public class p4635 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        while (n!=-1) {
            int prevT=0;
            int distance=0;
            for (int i=0;i<n;i++){
                int s = scanner.nextInt();
                int t = scanner.nextInt();
                distance=distance+s*(t-prevT);
                prevT=t;
            }
            System.out.println(distance+" miles");
            n=scanner.nextInt();
        }
        scanner.close();
    }
}
```
- 테스트런을 진행할 때 vscode 우상단의 재생버튼을 눌렀을 때 진행이 안되는 문제가 있었다. 
`Error: Main method not found in the file, please define the main method as: public static void main(String[] args)`
- class 이름이 main이 아니어서 일어나는 문제 같음, 콘솔창에 `java p4635.java`를 입력해서 클래스를 실행시키니까 문제없이 작동했다. 

### 7857
#### python
```python
n=int(input())
a=[input()]
byte=len(a[0])
for i in range(1,n):
    a.append(input())
    j=0
    while j<min(len(a[i-1]),len(a[i])) and a[i][j]==a[i-1][j]: 
        j+=1
    byte+=len(a[i])-j+1
print(byte)
```
- 문제를 이해하는게 어려웠어서 어떻게 하라는건지나 설명한다
- 일련의 문자열이 주어지면, 뒷 문자열을 저장할때 앞 문자열과 뒷 문자열을 공유해 두 문자열이 공유하는 부분까지는 `[j]`로 표기하고, 나머지 다른 부분은 원래대로 표기함
- 이때 압축하는 표시인 `[j]`는 1byte로 취급
- 입력받은 문자열은 모두 `a`에 저장
- `j`: 저번 문자열과 비교해 처음으로 다른 글자가 나올때까지의 갯수 카운팅
- 원래 문자열의 길이에서 압축된 `j`만큼 빼고, 압축표기의 1byte만큼 더해 `byte`를 계산한다. 즉 앞 문자열과 뒷 문자열이 겹치지 않으면, 그냥 1byte만 늘어난다(의도된 사양). 

#### java
```java
import java.util.Scanner;
public class p7857 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = Integer.parseInt(scanner.nextLine());
        String[] a = new String[n];
        a[0]=scanner.nextLine();
        int b = a[0].length();
        for (int i=1;i<n;i++){
            a[i]=scanner.nextLine();
            int min;
            if (a[i].length()<a[i-1].length()) { min=a[i].length(); }
            else { min = a[i-1].length(); }

            int j=0;
            while (j<min && a[i].charAt(j)==a[i-1].charAt(j)) { j++; }
            b+=a[i].length()-j+1;
        }
        scanner.close();
        System.out.println(b);
    }
}
```
- 처음에 `n`을 `nextInt()`로 받으려할땐 `a[0]`에 제대로 입력이 이루어지지 않아(빈 문자열로 입력됨) `a[1]`과 `a[0]`을 비교하려 할때 `StringIndexOutOfBoundsException`이 발생했었다. 
- `nextInt()`로 숫자를 받으면 버퍼에서 `\n`을 소거하지 않고 정수만 빼간다. 이 상태에서 바로 `nextLine()`으로 문자열을 받으려고 하면 버퍼에서 소거되지 않은 `\n`이 그대로 인식되어 빈 문자열로 인식해버리고 넘어가버린다. 
- 대응법은 `a[0]`를 입력받기 전에 `nextLine()`으로 먼저 버퍼를 소모시키거나 위에서처럼 `parseInt()`를 사용해 입력부분에서 `nextLine()`만 사용하는 방법이 있다. 