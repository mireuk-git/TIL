# Codekata
### 4635
#### python
```python
n=int(input())
while n!=-1:
    distance=0
    prev_t=0
    for i in range(n):
        s,t=map(int,input().split())
        distance+=s*(t-prev_t)
        prev_t=t
    print(f"{distance} miles")
    n=int(input())
```
#### java
```java
import java.util.Scanner;

public class p4635 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        while (n!=-1) {
            int prevT=0;
            int distance=0;
            for (int i=0;i<n;i++){
                int s = scanner.nextInt();
                int t = scanner.nextInt();
                distance=distance+s*(t-prevT);
                prevT=t;
            }
            System.out.println(distance+" miles");
            n=scanner.nextInt();
        }
        scanner.close();
    }
}
```
- 테스트런을 진행할 때 vscode 우상단의 재생버튼을 눌렀을 때 진행이 안되는 문제가 있었다. 
`Error: Main method not found in the file, please define the main method as: public static void main(String[] args)`
- class 이름이 main이 아니어서 일어나는 문제 같음, 콘솔창에 `java p4635.java`를 입력해서 클래스를 실행시키니까 문제없이 작동했다. 

### 7857
#### python
```python
n=int(input())
a=[input()]
byte=len(a[0])
for i in range(1,n):
    a.append(input())
    j=0
    while j<min(len(a[i-1]),len(a[i])) and a[i][j]==a[i-1][j]: 
        j+=1
    byte+=len(a[i])-j+1
print(byte)
```
- 문제를 이해하는게 어려웠어서 어떻게 하라는건지나 설명한다
- 일련의 문자열이 주어지면, 뒷 문자열을 저장할때 앞 문자열과 뒷 문자열을 공유해 두 문자열이 공유하는 부분까지는 `[j]`로 표기하고, 나머지 다른 부분은 원래대로 표기함
- 이때 압축하는 표시인 `[j]`는 1byte로 취급
- 입력받은 문자열은 모두 `a`에 저장
- `j`: 저번 문자열과 비교해 처음으로 다른 글자가 나올때까지의 갯수 카운팅
- 원래 문자열의 길이에서 압축된 `j`만큼 빼고, 압축표기의 1byte만큼 더해 `byte`를 계산한다. 즉 앞 문자열과 뒷 문자열이 겹치지 않으면, 그냥 1byte만 늘어난다(의도된 사양). 

#### java
```java
import java.util.Scanner;
public class p7857 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = Integer.parseInt(scanner.nextLine());
        String[] a = new String[n];
        a[0]=scanner.nextLine();
        int b = a[0].length();
        for (int i=1;i<n;i++){
            a[i]=scanner.nextLine();
            int min;
            if (a[i].length()<a[i-1].length()) { min=a[i].length(); }
            else { min = a[i-1].length(); }

            int j=0;
            while (j<min && a[i].charAt(j)==a[i-1].charAt(j)) { j++; }
            b+=a[i].length()-j+1;
        }
        scanner.close();
        System.out.println(b);
    }
}
```
- 처음에 `n`을 `nextInt()`로 받으려할땐 `a[0]`에 제대로 입력이 이루어지지 않아(빈 문자열로 입력됨) `a[1]`과 `a[0]`을 비교하려 할때 `StringIndexOutOfBoundsException`이 발생했었다. 
- `nextInt()`로 숫자를 받으면 버퍼에서 `\n`을 소거하지 않고 정수만 빼간다. 이 상태에서 바로 `nextLine()`으로 문자열을 받으려고 하면 버퍼에서 소거되지 않은 `\n`이 그대로 인식되어 빈 문자열로 인식해버리고 넘어가버린다. 
- 대응법은 `a[0]`를 입력받기 전에 `nextLine()`으로 먼저 버퍼를 소모시키거나 위에서처럼 `parseInt()`를 사용해 입력부분에서 `nextLine()`만 사용하는 방법이 있다. 

- 뻘짓하다 추가로 알아낸 것이 있어 여기에 서술한다. 
- Scanner 객체를 닫을 때 쓰는 `Scanner.close()`는 Scanner뿐만 아니라 `System.in`도 함께 닫는다. 
- 여기서 `System.in`이 닫히면 프로세스가 끝날때까지 다시 `System.in`을 사용할 수 없다. 
- `try-with-resource`는 블럭이 끝날때 사용하던 자원을 모두 닫아버린다. 즉 블럭 끝에서 `close()`가 자동호출 되는 것과 같다. 

# 정처기
## 소프트웨어 개발
####

> 02. White Box Testing에 대한 설명으로 옳지 않은 것은?
1. Base Path Testing, Boundary Value Analysis가 대표적인 기법이다.  V
2. Source Code의 모든 문장을 한번 이상 수행함으로서 진행된다. X
3. 모듈 안의 작동을 직접 관찰할 수 있다. 
4. 산출물의 각 기능별로 적절한 프로그램의 제어구조에 따라 선택, 반복 등의 부분들을 수행함으로써 논리적 경로를 점검한다. 

White Box Testing: 소스코드를 보면서, 데이터의 흐름 등을 확인(개발자위주)
문장검증
선택검증
경로검증(Base Path Testing)
조건검증

Black Box Testing: 소스코드를 보지 않고(사용자관점)
동등 분할 기법
경계값 분석 기법(Boundary Value Analysis)
오류 예측 기법
원인 결과 그래프 기법
의사결정 테이블 테스팅
상태전이 테스팅

기본경로탐사(Base Path Testing): 데이터가 어떤 경로를 따라가는지
소스코드를 보면서 논리적 경로를 점검하며 모든 문장을 한번이상 수행하며 모듈안의 작동을 직접 관찰