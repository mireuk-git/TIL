# CodeKata
### python
#### 16170
[link](https://www.acmicpc.net/problem/16170)

```python
from datetime import datetime, timedelta
now=datetime.now()
UTC=now-timedelta(hours=9)
print(UTC.year)
print(UTC.month)
print(UTC.day)
```
- 이렇게하면 한국시간대에서 UTC+0 기준으로 시간을 출력할 수 있다
- ...다만 백준 서버가 UTC+0를 서버시간으로 사용하고 있어서, 따로 Timedelta를 사용할 필요는 없고 현지시간을 출력해주면 된다. 
- ~~이럴거면 문제에 서버시간은 UTC+0을 기준으로 한다 라고 한줄 써주지 그랬냐~~

#### 8595
[link](https://www.acmicpc.net/problem/8595)
```python
n=int(input())
feed=input()
left=-1
s=0
for i in range(n):
    if ord(feed[i])>=48 and ord(feed[i])<=57:
        if left<0:
            left=i
    elif left>=0:
        s+=int(feed[left:i])
        left=-1
if ord(feed[i])>=48 and ord(feed[i])<=57:
    s+=int(feed[left:i+1])
print(s)
```
- `ord()`를 이용해 현재 인덱스가 숫자인지 글자인지 확인하고, 현재 인덱스가 숫자라면 `left`를 갱신
- `left`가 갱신되어 있는 상태에서 더이상 숫자가 나오지 않고 글자가 나온다면, `left`부터 현재 인덱스 `i-1`까지를 히든넘버 하나로 취급, 누적합 계산
- 단 끝이 숫자가 나오는 입력일 경우, 반복문까지의 코드만으로는 마지막 히든넘버의 합산이 제대로 이뤄지지 않기 때문에, 마지막까지 확실히 계산에 포함하기 위해 예외처리를 해야한다. 

#### 25707
[link](https://www.acmicpc.net/problem/25707)
```python
n=int(input())
marble=list(map(int,input().split()))
marble.sort()
s=0
for i in range(n-1): s+=marble[i+1]-marble[i]
s+=marble[-1]-marble[0]
print(s)
```
- 내림차순으로 정렬해 연결하면 차이가 최소인 팔찌가 만들어진다. 

# 정보처리기사
## 소프트웨어 개발
자료구조 문제가 많음

#### 정렬 알고리즘

> 01. 정렬된 N개의 데이터를 처리하는데 O(nlog2n)의 시간이 소요되는 정렬 알고리즘은? 
1. 선택정렬
2. 삽입정렬
3. 버블정렬
4. 합병정렬 V

> O(n2)
버블 정렬(Bubble sort): 인접한 원소끼리 비교, 한바퀴마다 마지막 하나가 정렬
선택 정렬(Selection sort): 전체 리스트 중 가장 작은 원소부터 정렬
삽입 정렬(Insertion sort): 자기보다 큰 요소가 나올때까지 뒤로 이동, 삽입
셸 정렬

> O(nlogn)
병합 정렬(Merge sort): 리스트를 반씩 쪼개 정렬 반복
힙 정렬(Heap sort): Tree모양의 Heap을 사용해 큰 원소부터 정렬
퀵 정렬(Quick sort): 피벗 하나를 정해 그보다 작은것과 큰것을 구분함, 최악의 경우 n2까지 나올 수 있음
트리 정렬(Tree sort): 가장 앞을 루트로 해 기준보다 크면 오른쪽 자식으로 작으면 왼쪽 자식으로, 왼쪽자식-자신-오른쪽자식 순으로 순회해서 리스트 정렬