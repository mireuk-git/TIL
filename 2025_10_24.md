# CodeKata
### 28446
[link](https://www.acmicpc.net/problem/28446)
#### python
```python
import sys
input=sys.stdin.readline

m=int(input().strip())
location={}
for i in range(m):
    request = input().strip()
    op,request = request.split(' ',1)
    if op=='1':
        x,w=map(int,request.split())
        location[w]=x
    if op=='2':
        w = int(request)
        print(location[w])
```
- `Dictionary`형으로 저장

#### java
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.StringTokenizer;

public class p28446{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        
        int m = Integer.parseInt(st.nextToken());
        HashMap<Integer,Integer> location = new HashMap<>();
        int op,x,w;
        for (int i=0;i<m;i++){
            st = new StringTokenizer(br.readLine());
            op = Integer.parseInt(st.nextToken());
            switch (op) {
                case 1: 
                    x = Integer.parseInt(st.nextToken()); 
                    w = Integer.parseInt(st.nextToken());
                    location.put(w,x);
                    break;
                case 2:
                    w = Integer.parseInt(st.nextToken());
                    System.out.println(location.get(w));
                    break;
            }
        }
    }
}
```
- 객체지향으로 작성한다면, `location` HashMap을 따로 클래스로 분리할 수 있을 것이다. 
```java
class locationManager{
    private final HashMap<Integer,Integer> location = new HashMap<>();
    
    public void register(int x, int w){
        location.put(w,x);
    }

    public int getLocation(int w){
        return location.get(w);
    }
}
```

# 정보처리기사
## 페이지 교체 알고리즘
메모리에 필요한 페이지가 없을 때(page-fault) 프레임을 비우고 로딩하기 위해 희생당할 프레임(victim frame)을 고르는 알고리즘
쓰래싱: 
페이징 기법: 내부단편화
세그멘테이션 기법: 외부단편화

#### FIFO
First In First Out
가장 먼저 메모리에 올라온 페이지를 가장 먼저 보냄
들어온 시간을 저장하거나 올라온 순서를 큐로 저장
Belady`s Anomaly: 프레임 수가 늘어나도 page-fault가 해소되지 않고 늘어남

>01\. **3개의 페이지 프레임**을 갖는 시스템에서 페이지 참조 순서가 1,2,1,0,4,1,3 일 경우, **FIFO** 알고리즘에 의한 페이지 교체의 경우 **프레임의 최종 상태**는?
>1. 1,2,0
>2. 2,4,3
>3. 1,4,2
>4. 4,1,3 V

1 | 1 
2 | 1 2
1 | 1 2
0 | 1 2 0
4 | 4 2 0
1 | 4 1 0
3 | 4 1 3

>02\. **3개의 페이지 프레임**을 가진 기억장치에서 페이지 번호 순으로 요청했을 때 교체 알고리즘으로 **FIFO** 방법을 사용한다면 **몇번의 페이지 부재**가 발생하는가?
> > 순서: 2,3,2,1,5,2,4,5,3,2,5,2
>1. 7번
>2. 8번
>3. 9번 V
>4. 10번

2 | 2 (O)
3 | 2 3 (O)
2 | 2 3 (X)
1 | 2 3 1 (O)
5 | 5 3 1 (O)
2 | 5 2 1 (O)
4 | 5 2 4 (O)
5 | 5 2 4 (X)
3 | 3 2 4 (O)
2 | 3 2 4 (X)
5 | 3 5 4 (O)
2 | 3 5 2 (O)

>03\. **3개의 페이지를 수용**할 수 있는 주기억장치가 있으며, **초기에는 모두 비어 있다**고 가정한다. 다음의 순서로 페이지 참조가 발생할 때, **FIFO** 페이지 교체 알고리즘을 사용할 경우 **몇 번의 페이지 결함**이 발생하는가?
>> 페이지 참조 순서: 1,2,3,1,2,4,1,2,5
>1. 4
>2. 5
>3. 6
>4. 7 V

1 | 1 (O)
2 | 1 2 (O)
3 | 1 2 3 (O)
1 | 1 2 3 (X)
2 | 1 2 3 (X)
4 | 4 2 3 (O)
1 | 4 1 3 (O)
2 | 4 1 2 (O)
5 | 5 1 2 (O)

#### LRU
Least Recently Used
가장 오랫동안 사용하지 않은 페이지 교체
큐로 구현, 사용된 큐는 위로 이동, 교체시 하단을 삭제

> 01\. **3개의 페이지를 수용**할 수 있는 주기억장치가 있으며, **초기에는 모두 비어 있다**고 가정한다. 다음의 순서로 페이지 참조가 발생할 때, **LRU(Least Recently Used)** 페이지 교체 알고리즘을 사용할 경우 **몇 번의 페이지 결함**이 발생하는가?
>> 페이지 참조 순서: 1,2,3,1,2,4,1,2,5,4
>1. 6 V
>2. 7
>3. 8
>4. 9

1 | 1 (O)
2 | 1 2 (O)
3 | 1 2 3 (O)
1 | 2 3 1 (X)
2 | 3 1 2 (X)
4 | 1 2 4 (O)
1 | 2 4 1 (X)
2 | 4 1 2 (X)
5 | 1 2 5 (O)
4 | 2 5 4(O)

>02\. **3개의 페이지 프레임**을 갖는 시스템에서 페이지 참조 순서가 **1,2,1,0,4,1,3**일 경우 LRU(Least Recently Used) 알고리즘에 의한 페이지 대치의 최종 결과는?
>1. 1,4,3 V
>2. 1,2,0
>3. 2,4,3
>4. 0,1,3

1 | 1 (O)
2 | 1 2 (O)
1 | 1 2 (X)
0 | 1 2 0 (O)
4 | 1 4 0 (O)
1 | 1 4 0 (X)
3 | 1 4 3 (O)

>03\. **4개의 페이지를 수용**할 수 있는 주기억장치가 있으며, **초기에는 모두 비어 있다**고 가정한다. 다음의 순서로 페이지 참조가 발생할 때, **LRU** 페이지 교체 알고리즘을 사용할 경우 **몇 번의 페이지 결함**이 발생하는가?
>> 페이지 참조 순서: 1,2,3,1,2,4,1,2,5
>1. 4회
>2. 5회 V
>3. 6회 
>4. 7회

1 | 1 (O)
2 | 1 2 (O)
3 | 1 2 3 (O)
1 | 1 2 3 (X)
2 | 1 2 3 (X)
4 | 1 2 3 4 (O)
1 | 1 2 3 4 (X)
2 | 1 2 3 4 (X)
5 | 1 2 5 4 (O)

#### LFU
Least Frequently Used
참조횟수가 가장 적은 페이지 교체
교체 대상이 여러개면 가장 오랫동안 사용하지 않은 것을 교체
LRU와 달리 가장 최근에 불러온 페이지가 교체될 수 있음

>01\. **3개의 페이지 프레임**으로 구성돈 기억장치에서 다음과 같은 순서대로 페이지 요청이 일어날 떄, 페이지 교체 알고리즘으로 **LFU(Least Frequently Used)**를 사용한다면 **몇 번의 페이지 부재**가 발생하는가? (단, 초기 페이지 프레임은 비어있다고 가정한다.)
>> 요청된 페이지 번호의 순서: 2,3,1,2,1,2,4,2,1,3,2
>1. 4회
>2. 5회 V
>3. 6회
>4. 7회

2 | 2 (O)
3 | 2 3 (O)
1 | 2 3 1 (O)
2 | 2 3 1 (X)
1 | 2 3 1 (X)
2 | 2 3 1 (X)
4 | 2 4 1 (O)
2 | 2 4 1 (X)
1 | 2 4 1 (X)
3 | 2 3 1 (O)
2 | 2 3 1 (X)

>02\. **4개**의 페이지 프레임으로 구성된 기억장치에서 다음과 같은 순서대로 페이지 요청이 일어날 때, 페이지 교체 알고리즘으로 **LFU(Least Frequently Used)**를 사용한다면 페이지 대치의 최종 결과는? (단, 초기 페이지 프레임은 비어있다고 가정한다.)
>1. 2,3,1,5 V
>2. 1,2,3,5
>3. 2,3,5,4
>4. 1,2,3,4

#### OPT
Optimal
나중에 사용되지 않을 페이지를 예측해 교체
이론적으로만 존재

#### NUR
Not Used Recently
최근에 사용하지 않은 페이지 교체
참조비트: 참조되면 1, 안되면 0
변형비트: 페이지 내용이 변경됐으면 1, 안됐으면 0

#### SCR
Second Chance Replacement
FIFO의 단점 보완, 자주 사용되는 페이지의 교체 방지