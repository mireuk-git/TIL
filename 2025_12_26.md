# Codekata
### 27829
[link](https://www.acmicpc.net/problem/27829)
#### python
```python
import sys
input=sys.stdin.readline

t=int(input().strip())
for test_case in range(t):
    input()
    ng,nm=map(int,input().strip().split())
    g = sorted(list(map(int,input().strip().split())))
    m = sorted(list(map(int,input().strip().split())))
    gi,mi=0,0
    while (gi<ng and mi<nm):
        if g[gi]<m[mi]: gi+=1
        else: mi+=1
    if gi>=ng: print("MechaGodzilla")
    elif mi>=nm: print("Godzilla")
    else: print("uncertain")
```
- `g`,`m` list를 정렬한 후 더블 포인터 `gi`,`mi`를 운용해 한마리가 쓰러질 때마다 포인터를 옮김, 포인터가 끝까지 이동한 리스트가 패배한 걸로 처리

#### java
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.StringTokenizer;

public class p27829 {
    public static void main(String[] args)throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int t = Integer.parseInt(st.nextToken());
        for (int testCase=1;testCase<=t;testCase++){
            br.readLine();
            st = new StringTokenizer(br.readLine());
            int ng = Integer.parseInt(st.nextToken());
            int nm = Integer.parseInt(st.nextToken());

            st = new StringTokenizer(br.readLine());
            List<Integer> g = new ArrayList<>();
            for (int i=0;i<ng;i++) g.add(Integer.parseInt(st.nextToken()));
            st = new StringTokenizer(br.readLine());
            List<Integer> m = new ArrayList<>();
            for (int i=0;i<nm;i++) m.add(Integer.parseInt(st.nextToken()));
            int gi=0,mi=0;
            Collections.sort(g);
            Collections.sort(m);

            while(gi<ng && mi<nm){
                if (g.get(gi) < m.get(mi)) gi++;
                else mi++;
            }

            if (gi>=ng) System.out.println("MechaGodzilla");
            else if (mi>=nm) System.out.println("Godzilla");
            else System.out.println("uncertain");
        }
    }
}
```

# 정보처리기사
### 디스크 스케줄링
#### LOOK
SCAN 변형
현재 진행방향에서 더이상 남은 요청이 없을 경우 방향 전환

 > 01\. 디스크 스케줄링 방법 중 `LOOK 방식`을 사용할 때 `현재 헤드가 60에서 50으로 이동`해 왔을 경우 다음과 같은 디스크 큐에서 `가장 먼저 처리되는 것`은?
 > 대기큐: 70,80,100,90

50(방향전환) > 70 > 80 > 90 > 100

> 02\. 다음과 같은 트랙이 요청되어 큐에 도착하였다. 모든 트랙을 서비스하기 위하여 `LOOK` 스케줄링 기법이 사용되었을 때, `모두 몇 트랙의 헤드 이동`이 생기는가? (단, `현재 헤드의 위치는 50트랙이고 헤드는 트랙 0방향으로 움직인다`.)
> 대기큐: 10,35,40,55

50 > 40 > 35 > 10(방향전환) > 55
40+45 = 85

#### C-LOOK
C-SCAN의 변형판
현재 진행에서 더 남은 처리가 없으면 다시 시작점으로

>01\. 디스크의 서비스 요청 대기 큐에 도착한 요청이 다음과 같을 때 `C-LOOK` 스케줄링 알고리즘에 의한 헤드의 `총 이동거리`는 얼마인가?(단, `현재 헤드의 위치는 50`에 있고, `헤드의 이동방향은 0에서 199`이다)
> 대기큐: 65,112,40,16,90,170,165,35,180

50 > 65 > 90 > 112 > 165 > 170 > 180(초기화) > 16 > 35 > 40
130+164+24=318
