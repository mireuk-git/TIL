# Codekata
### 13567
[link](https://www.acmicpc.net/problem/13567)
#### python
```python
m,n=map(int,input().split())
x,y=0,0
dx,dy=1,0
valid=True
for i in range(n):
    command,d=input().split()
    d=int(d)
    if valid:
        if command == 'TURN':
            if d==0:
                if dx==1: dx,dy=0,1
                elif dy==1: dx,dy=-1,0
                elif dx==-1: dx,dy=0,-1
                elif dy==-1: dx,dy=1,0
            elif d==1:
                if dx==1:dx,dy=0,-1
                elif dy==-1: dx,dy=-1,0
                elif dx==-1: dx,dy=0,1
                elif dy==1: dx,dy=1,0
        elif command == 'MOVE':
            if 0<=x+d*dx<=m and 0<=y+d*dy<=m:
                x+=d*dx
                y+=d*dy
            else: valid=False
if not valid: print(-1)
else: print(x,y)
```
- `sys.stdin.readline`을 이용했으면 시간이 더 단축됐을지도

#### java
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class p13567 {
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int m = Integer.parseInt(st.nextToken());
        int n = Integer.parseInt(st.nextToken());
        int x=0, y=0;
        int dx=1, dy=0;
        boolean valid = true;

        for (int i=0;i<n;i++){
            st = new StringTokenizer(br.readLine());
            String command = st.nextToken();
            int d = Integer.parseInt(st.nextToken());
            if (valid) {
                if (command.equals("TURN")) {
                    if (d==0) {
                        if (dx==1) { dx=0; dy=1; }
                        else if (dy==1) { dx=-1; dy=0; }
                        else if (dx==-1) { dx=0; dy=-1; }
                        else if (dy==-1) { dx=1; dy=0; }
                    }
                    else if (d==1) {
                        if (dx==1) { dx=0; dy=-1; }
                        else if (dy==-1) { dx=-1; dy=0; }
                        else if (dx==-1) { dx=0; dy=1; }
                        else if (dy==1) { dx=1; dy=0; }
                    }
                }
                else if (command.equals("MOVE")){
                    if (0<=x+dx*d && x+dx*d<=m && 0<=y+dy*d && y+dy*d<=m){
                        x+=dx*d;
                        y+=dy*d;
                    }
                    else valid = false;
                }
            }
        }
        if (!valid) System.out.println(-1);
        else System.out.println(x+" "+y);
    }
}
```

# 정보처리기사
## 디스크 스케줄링
#### SCAN
한방향으로 이동하면서 처리하는 기법

> 01\. 디스크 스케줄링에서 `SCAN`기법을 사용할 경우, 다음과 같은 작업대기 큐의 작업들을 수행하기 위한 헤드의 총 트랙 이동 거리는? (단, 초기 헤드의 위치는 30이고, 현재 0번 트랙으로 이동중)
>대기 큐: 3,7,15,38,46

30 > 15 > 7 > 3 > (0) > 38 > 46
30+46 = 76

> 02\. 디스크 스케줄링 기법 중 `SCAN`을 사용하여 다음 작업대기큐의 작업을 모두 처리하고자 할 경우, 가장 최후에 처리되는 트랙은? (단, 현재 디스크 헤드는 50트랙에서 40트랙으로 이동했다고 가정한다.)
> 대기큐: 7,55,15,38,3

40 > 38 > 15 > 7 > 3 > 55

> 03\. 디스크에서 헤드가 70트랙을 처리하고 60트랙으로 이동해 왔다. 디스크 스케줄링 기법으로 SCAN 방식을 사용할 때 디스크 대기큐에서 가장 먼저 처리되는 트랙은?
> 대기큐: 20,50,95,100

60 > 50 > 20 > 95 > 100

#### C-SCAN
처리할 게 없어도 일단 양쪽 끝단으로 이동하는 과정까지 포함해 주어야 함

> 01\. 트랙 번호가 0부터 199인 200개의 트랙을 가진 디스크가 있다. 디스크 스케줄링 기법 중 `C-SCAN`을 사용하여 다음과 같은 작업 대기 큐(디스크 큐)의 작업을 하고자 하는 경우, 처리되는 트랙의 순서를 바르게 나열하시오. (단, 현재 디스크 헤드는 트랙 35에서 트랙 47로 이동해왔다고 가정한다.)
> 대기큐: 139,22,175,86,13,158

47 > 86 > 139 > 158 > 175 > (199) > (0) > 13 > 22
