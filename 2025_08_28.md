# CodeKata
### python
#### 30458
[link](https://www.acmicpc.net/problem/30458)
```python
from collections import Counter
n=int(input())
s=input()
c=Counter(s)
result="Yes"
for i in c.keys():
    if c[i]%2 and i!=s[n//2]: result="No"
print(result)
```
- `c`: 입력받는 문자열 `s`의 글자 당 개수를 관리하는 `Counter`
- 연산을 몇번을 수행하든 제한은 없으므로 각 글자가 짝수번 나온다면 팰린드롬이 될 수 있다. 만약 길이가 홀수라면, 홀수번 나오는 글자는 오직 하나만 가능하다. 
- `s`의 가운데, 즉 `s[n//2]`는 문제에서 제시한 연산의 대상이 될 수 없다. 다시말해 `s[n//2]`는 교환할 수 없다. 
- 따라서 `c`에서 홀수번 나오는 문자가 있다면 그것은 반드시 `s[n//2]`에 있어야 팰린드롬이 되며, 아니라면 그것은 팰린드롬이 아니다. 

#### 12981
[link](https://www.acmicpc.net/problem/12981)
<b>1st try:</b>

```python
r,g,b=map(int,input().split())
count=0
count+=r//3
r%=3
count+=g//3
g%=3
count+=b//3
b%=3
count+=max([r,g,b])
print(count)
```
- 같은색끼리 최대한 눌러담고 나머지끼리 담으면 최소로 사용할 수 있을거라 생각했는데... 다른 분기가 있나?
- 나머지 처리에서 틀렸다. (0,2,0)으로 남았으면 상자 하나면 되는데 2개가 들어간다. 

<b>2nd try:</b>

- 나머지는 0,1,2 셋 중 하나가 가능하다. 여기서 2가 한색깔에서만 나온다면 박스 1개로 충분하다. 나머지의 경우라면 가장 많이 남은 색의 갯수만큼 박스가 필요하다. 
```python
r,g,b=map(int,input().split())
count=0
count+=r//3
r%=3
count+=g//3
g%=3
count+=b//3
b%=3
if [r,g,b].count(0)==2: count+=1
else: count+=max(r,g,b)
print(count)
```

#### 4368
[link](https://www.acmicpc.net/problem/4368)
```python
import sys
feed=sys.stdin.readline().strip()
dictionary=dict()
while feed!='':
    value,key=feed.split()
    dictionary[key]=value
    feed=sys.stdin.readline().strip()

words=sys.stdin.readlines()
for i in words:
    word=i.strip()
    if word in dictionary.keys():
        print(dictionary[word])
    else:
        print("eh")
```
- 딕셔너리를 이용해 사전을 만든다. 이때 외국어가 key가 되어야 찾기에 용이하다. 
- 입력받는게 주요 작업이라 `sys.stdin.readline`을 미리 import시켜놨다. 
