# Codekata
### 1769
[link](https://www.acmicpc.net/problem/1769)
#### python
```python
x=input()
cnt=1
next_x=0
for i in x:
    next_x+=int(i)
if len(x)==1: cnt-=1
x=next_x

while x>9:
    next_x = 0
    while x>0:
        next_x+=x%10
        x//=10
    x=next_x
    cnt+=1
print(cnt)
if x%3==0: print("YES")
else: print("NO")
```
- 백만자리의 입력은 파이썬이라도 정수형으로 처리할 수 없다. 혹은 프로그램에서 정수형이 차지하는 크기가 너무 커지거나, 제대로 효율이 안나올 수도 있다. 
- 입력을 그대로 정수로 받기보단, 문자열 그대로 받아서 한자리씩 정수형으로 바꾸는 방법이 유효

#### java
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class p1769 {
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        String input = st.nextToken();

        int cnt = 1;
        int nextX = 0;
        for (int i=0;i<input.length();i++){
            nextX += (int)input.charAt(i) - 48;
        }
        if (input.length()==1) cnt-=1;
        int x = nextX;

        while (x>9){
            nextX=0;
            while (x>0){
                nextX+=x%10;
                x/=10;
            }
            cnt+=1;
            x=nextX;
        }
        System.out.println(cnt);
        if (x%3==0) System.out.println("YES");
        else System.out.println("NO");
    }
}
```
- python과 동작 방식이 같다. 

# 정보처리기사
## 프로세스 상태전이도
프로세스의 생명주기
준비 -(Dispatch)-> 실행 -(Block)-> 대기 -(Wake Up)-> 준비

## CPU 스케쥴링
~~대환장비유~~
선점형: 실행중인 프로세스를 Block하고 우선순위가 위인 프로세스를 먼저 Dispatch할 수 있음
~~화장실 관리자가 똥싸던 사람을 끌어내리고 급똥인 사람을 집어넣을 수 있다~~
Round Robin(RR), Shortest Remaining Time first(SRT), Multi Level Queue(MLQ), Multi Level Feedback Queue(MFQ)

비선점형: 프로세스가 실행중이면 해당 프로세스가 끝날 때까지 새로운 프로세스가 점유할 수 없음
~~화장실 관리자가 없어 급똥이 와도 안의 사람을 끄집어 낼 수 없다~~
FCFS, SJF, HRN, 우선순위, 기한부

기아현상: 프로세스가 우선순위가 밀려 리소스를 오랫동안 할당받지 못하는 현상
에이징: 기아현상을 방지하기 위해 일정시간동안 대기한 프로세스의 우선순위를 한단계씩 높여줌

대기시간: 작업 들어가기 전 대기하는 시간
반환시간: 대기부터 작업이 끝날 때까지의 시간

#### Round Robin(RR)
프로세스마다 같은 크기의 CPU 시간을 할당
선점형: 프로세스가 할당된 시간 내에 처리를 완료하지 못하면 준비 큐 리스트의 맨 뒤로 보내버림

#### Shortest Remaining Time first(SRT)
가장 짧은 시간이 소요되는 프로세스를 먼저 수행
선점형: 남은 시간이 더 짧은 프로세스가 큐에 생기면 짧은 프로세스가 선점됨

>1\. 다음 표는 단일 CPU에 진입한 프로세스의 도착 시간과 처리하는 데 필요한 실행 시간을 나타낸 것이다. 프로세스 간 문맥 교환에 따른 오버헤드는 무시한다고 할 때, `SRT`(Shortest Remaining Time) 스케쥴링 알고리즘을 사용한 경우 네 프로세스의 `평균 반환시간`은?
> 도착시간 / 실행시간
> p1 - 0 / 8, p2 - 2 / 4, p3 - 4 / 1, p4 - 6 / 4
>1. 4.25
>2. 7 v
>3. 8.75
>4. 10

p1(0,2) > p2(2,4) > p3(4,5) > p2(5,7) > p4(7,11) > p1(11,17)
(17-0+7-2+5-4+11-6)/4=7

>2\. 다음 표는 단일 cpu에 진입한 프로세스의 도착 시간과 처리하는 데 필요한 실행 시간을 나타낸 것이다. 프로세스 간 문맥 교환에 따른 오버헤드는 무시한다고 할 때, `SRT`스케줄링 알고리즘을 사용한 경우 네 프로세스의 `평균 반환시간`은?
>도착시간 / 실행시간
> P1 - 0 / 7, P2 - 2 / 4, P3 - 4 / 1, P4 - 5 / 4
>1. 4.25
>2. 7 V
>3. 8.75
>4. 10

P1(0,2) > P2(2,4), > P3(4,5) > P2(5,7) > P4(7,11) > P1(11,16)
(16-0+7-2+5-4+11-5)/4 = 28/4 = 7

#### Multi Level Queue(MLQ)
우선순위로 나누어진 여러 큐 중에 들어오는 작업이 어디로 갈지 결정해서 수행, 우선순위가 높은 큐의 작업이 먼저 수행
선점형

#### Multi Level Feedback Queue(MLFQ, MFQ)
MLQ+RR
프로세스가 큐들 사이를 이동할 수 있음
한 프로세스가 너무 많은 시간을 소요하면 하위 큐로 삽입
최하위에선 RR 실행

#### FCFS
First Come First Served
비선점형
대기 큐에 먼저 온 프로세스가 먼저 CPU에 할당

>01\. 다음은 CPU에 서비스를 받으려고 도착한 수선대로 프로세스와 그 서비스 시간을 나타낸다. `FCFS` CPU Scheduling에 의해서 프로세스를 처리한다고 했을 경우 프로세스의 평균 `대기시간`은?
> p1 - 24, p2 - 3, p3 - 3
>1. 15
>2. 16
>3. 17 V
>4. 18

p1 - 0
p2 - 24
p3 - 24 + 3
(24+27)/3=17

>02\. 다음과 같은 3개의 작업에 대해 `FCFS` 알고리즘을 사용할 때, 임의의 작업 순서로 얻을 수 있는 `최대` 평균 `반환 시간`을 T, `최소` 평균 `반환 시간`을 t라고 가정했을 경우, T-t의 값은?
> p1 - 9, p2 - 3, p3 - 12
>1. 3
>2. 4
>3. 5
>4. 6 V

최대: p3, p1, p2 순
p3 - 12
p1 - 12 + 9
p2 - 12 + 9 + 3
T = (12 + 21 + 24) / 3 = 19

최소: p2, p1, p3 순
p2 - 3
p1 - 3 + 9
p3 - 3 + 9 + 12
t = (3 + 12 + 24) / 3 = 13

>03\. 다음과 같은 3개의 작업에 대하여 `FCFS` 알고리즘을 사용할 때, 임의의 작업 순서로 얻을 수 있는 최대 평균 `반환` 시간을 T, 최소 평균 `반환` 시간을 t라고 가정했을 경우 T-t의 값은?
> p1 - 9, p2 - 6, p3 - 12
>1. 3
>2. 4 V
>3. 5
>4. 6

최대: p3, p1, p2 순
p3 - 12
p1 - 12 + 9
p2 - 12 + 9 + 6
T = (12 + 21 + 27) / 3 = 20

최소: p2, p1, p3 순
p2 - 6
p1 - 6 + 9
p3 - 6 + 9 + 12
t = (6 + 15 + 27) / 3 = 16

#### SJF
Shortest Job First
실행시간이 가장 짧은 직업부터
비선점형

>01\. 다음과 같은 프로세스들이 차례로 준비상태 큐에 들어왔을 경우 SJF 스케줄링 기법을 이용하여 제출시간이 없는 경우의 평균 `실행시간`은?
>p1 - 18, p2 - 6, p3 - 9
>1. 10
>2. 11
>3. 18 V
>4. 24

(6+9+18)/3 = 11

>02\. 대기하고 있는 프로세스 p1, p2, p3, p4의 처리시간은 24[ms], 9[ms], 15[ms], 10[ms]일때, 최단 작업 우선(`SJF`) 스케쥴링으로 처리했을 때 `평균 대기 시간`은 얼마인가?
>1. 8.5[ms]
>2. 14.5[ms]
>3. 15.5[ms] V
>4. 25.25[ms]

p2 - 0
p4 - 9
p3 - 9 + 10 = 19
p1 - 19 + 15 = 34
(9+19+34)/4 = 15.5

>03\. `SJF(Shortest Job First)` 스케줄링에서 다음과 같은 작업들이 준비상태 큐에 있을 때 평균 `반환시간`과 평균 `대기시간`은?
> p1 - 6, p2 - 3, p3 - 8, p4 - 7
>1. 평균 반환시간:13, 평균 대기시간:7 V
>2. 평균 반환시간:13, 평균 대기시간:9
>3. 평균 반환시간:15, 평균 대기시간:7
>4. 평균 반환시간:15, 평균 대기시간:9

반환시간/대기시간
p2 - 3/0
p1 - 9/3
p4 - 16/9
p3 - 24/16
(3+9+16+24)/4=13 / (3+9+16)/4=7

>04\. 다음과 같은 Task List에서 `SJF` 방식으로 Scheduling 할 경우 `Task2`의 종료 시간을 구하면? (`도착시간`/`실행시간`)
> Task1 - 0/6, Task2 - 1/3, Task3 - 2/4
>1. 3
>2. 6
>3. 9 V
>4. 13

SJF - 비선점형(중간에 빼낼 수 없음)
t1 > t2 > t3
t1 - 6
t2 - 6 + 3
t3 - 9 + 4

#### HRN
Highest Response ratio Next
SJF의 긴 작업의 기아현상 보완
우선순위(중요도): (대기시간 + 실행시간) / 실행시간 ( = 시스템 응답시간) (에이징)

>1\. `HRN(Highest Response-ratio)` 방식으로 스케줄링할 경우, 입력된 작업이 다음과 같을 때 `우선순위가 가장 높은` 작업은?
>`대기시간`/`서비스시간`
>A - 8 / 2, B - 10 / 6, C - 15 / 7, D - 20 / 8
>1. A V
>2. B
>3. C
>4. D

(8+2)/2 = 5
(10+6)/6 = 2.67
(15+7)/7 = 3.XX
(20+8)/8 = 3.XX

>2\. `HRN` 스케쥴링 방식에서 입력돈 작업이 다음과 같을 때 `우선순위가 가장 높은` 것은?
> `대기시간` / `서비스시간`
> A - 5 / 20, B - 40 / 20, C - 15 / 45, D - 20 / 2
>1. A
>2. B
>3. C
>4. D V

(5+20)/20 = 1.25
(40+20)/20 = 3
(15+45)/45 = 1.33..
(20+2)/2 = 11

>3\. `HRN` 방식으로 스케줄링 할 경우, 입력된 작업이 다음과 같을 때 우선순위가 높은 순서부터 차례로 옳게 나열한 것은?
> `대기시간` / `서비스시간`
> A - 40 / 20, B - 20 / 20, C - 70 / 10, D - 120 / 30
>1. B → A → C → D
>2. B → A → D → C
>3. C → D → A → B V
>4. D → C → A → B

(40+20)/20 = 3
(20+20)/20 = 2
(70+10)/10 = 8
(120+30)/30 = 5

#### 기한부
정해진 시간 안에 완료하지 못하면 프로세스를 제거하거나 처음부터 다시 실행
