# Codekata
### 26500
[link](https://www.acmicpc.net/problem/26500)
#### python
```python
n=int(input())
for i in range(n):
    a,b=map(float,input().split())
    M,m=max(a,b),min(a,b)
    print(round(M-m,1))
```
- python의 `round()`는 IEEE-754 기준을 따른다
- IEEE-754: 짝수 쪽으로 반올림(2.5-> 2, 3.5-> 4)

#### java
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class p26500 {
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        for (int i=0;i<n;i++){
            st = new StringTokenizer(br.readLine());
            float a = Float.parseFloat(st.nextToken());
            float b = Float.parseFloat(st.nextToken());
            
            System.out.printf("%.1f%n", Math.max(a,b)-Math.min(a,b));
        }
    }
}
```
- IEEE-754를 의식하지 않는다면 이 코드가 맞겠지만, 문제가 아무래도 python의 IEEE-754를 의도한 듯 하여 위 코드에 불합격을 줬다. 

```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.StringTokenizer;

class PyRound {
    public static double pyRound(double value, int ndigits) {
        BigDecimal bd = BigDecimal.valueOf(value);
        bd = bd.setScale(ndigits, RoundingMode.HALF_EVEN);
        return bd.doubleValue();
    }
}

public class p26500 {
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        for (int i=0;i<n;i++){
            st = new StringTokenizer(br.readLine());
            float a = Float.parseFloat(st.nextToken());
            float b = Float.parseFloat(st.nextToken());
            System.out.println(PyRound.pyRound(Math.max(a,b)-Math.min(a,b),1));
        }
    }
}
```
- IEEE-754를 적용한 형태로 해보면 이렇게 코드가 작성된다. 
- 근데 왜 아직도 틀렸습니다 이러는건지 난 도저히 모르겠다 뭐 어떻게 만들어놓은거야

### 18795
[link](https://www.acmicpc.net/problem/18795)
#### python
```python
n,m=map(int,input().split())
a=list(map(int,input().split()))
b=list(map(int,input().split()))
trash=sum(a)+sum(b)
print(trash)
```
- 같은 열과 행의 문들이 쓰레기값이 같으므로 어차피 어느 길로 가든 쓰레기값은 똑같다. 

#### java
```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.util.StringTokenizer;

public class p18795 {
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        long[] a = new long[n];
        long[] b = new long[m];
        st = new StringTokenizer(br.readLine());
        for (int i=0;i<n;i++) { a[i] = Long.parseLong(st.nextToken()); }
        st = new StringTokenizer(br.readLine());
        for (int i=0;i<m;i++) { b[i] = Long.parseLong(st.nextToken()); }

        BigInteger trash = new BigInteger("0");
        for (int i=0;i<n;i++) { trash=trash.add(BigInteger.valueOf(a[i])); }
        for (int i=0;i<m;i++) { trash=trash.add(BigInteger.valueOf(b[i])); }
        System.out.println(trash);
    }
}
```
- Integer의 범위는 -2^31~2^31-1
- Long의 범위는 -2^63~2^63-1
- 이보다 큰 값은 BigInteger를 사용하면 계산할 수 있다. 