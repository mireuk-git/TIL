# CodeKata
### python
#### 5567
[link](https://www.acmicpc.net/problem/5567)

```python
n=int(input())
m=int(input())
mat=[[-1]*(n+1) for _ in range(n+1)]

for _ in range(m):
    a,b=map(int,input().split())
    mat[a][b],mat[b][a]=1,1

l=[]
for i in range(1,n+1):
    if mat[1][i]==1:
        l.append(i)
        for j in range(2,n+1):
            if mat[i][j]==1: l.append(j)
l=set(l)
print(len(l))
```
- 다리를 한번만 건너면 되는 다리 건너기 문제
- `1`의 이웃을 방문하고 이웃의 이웃까지만 방문하는 `dfs`
- `l`: 방문한 번호를 저장하는 list, 이후 set으로 변환해 중복 요소를 모두 제거함

#### 14620
[link](https://www.acmicpc.net/problem/14620)
<b>1st try:</b>

```python
n=int(input())
mat=[list(map(int,input().split())) for _ in range(n)]

l=[float('inf')]*3
for i in range(1,n-1):
    for j in range(1,n-1):
        cost=sum(mat[i][j-1:j+2])+mat[i-1][j]+mat[i+1][j]
        if cost<l[-1]:
            l[-1]=cost
            print(f"({i},{j}) cost:{cost}")
            l.sort()

print(sum(l))
```
- `cost`: (`i`,`j`)에 꽃을 심었을때 드는 비용
- `l`: 최소비용인 좌표 3곳을 저장하는 리스트, 새로 업데이트 될 때는 가장 큰 값을 새로운 값으로 대체하고 값이 대체될 때마다 새로 정렬함
- 아 꽃잎이 겹칠 수 없는걸 상정하지 못했구나...