# 정보처리기사
## 소프트웨어 개발
형상, 배포, 패키징

> 01.\ 정렬된 n개의 데이터를 처리하는 데 `O(nlogn)`의 시간이 소요되는 정렬 알고리즘은?
> 1. 선택정렬
> 2. 삽입정렬
> 3. 버블정렬
> 4. 합병정렬 V

O(n^2): 선택정렬, 삽입정렬, 버블정렬, 셸정렬
O(nlogn): merge(합병/병합), heap(힙), quick(퀵)
Quick의 경우 worstcase가 O(n^2)

> 02\. White Box Testing에 대한 설명으로 옳지 않은 것은>
>1. Base Path Testing, Boundary Value Analysis가 대표적인 기법이다. V
>2. Source Code의 모든 문장을 한번 이상 수행함으로서 진행된다. X
>3. 모듈 안의 작동을 직접 관찰할 수 있다. 
>4. 산출물의 각 기능별로 적절한 프로그램의 제어구조에 따라 선택, 반복 등의 부분들을 수행함으로써 논리적 경로를 점검한다.

Boundary Value Analysis – Blackbox testing
WhiteBox Testing – 모든 문장을 수행하며, 논리적 경로 점검, 내부 작동 직접 관찰, 개발자 관점
문장검증, 선택검증, 경로검증, 조건검증
BlackBox Testing – 사용자관점
동등 분할 기법, 경계값 분석 기법, 오류 예측 기법, 원인 결과 그래프 기법, 의사결정 테이블 테스팅, 상태 전이 테스팅
동등 분할 기법 – 모든 집합에 대해 대표값 하나씩 넣기
경계값 분석 – 경계값-1, 경계값, 경계값+1 집어넣어보기

>03\. 소프트웨어 품질 측정을 위해 개발자 관점에서 점검해야할 항목으로 옮은 것은?
>1. 정확성
>2. 무결성
>3. 사용성 x
>4. 간결성 v

소프트웨어 품질 표준
- 정확성: 사용자의 요구 사항을 만족시키는 정도
- 신뢰성: 기능상의 장애 없이 의도한 임무 수행
- 효율성: 시스템 자원과 코드량 최적화
- 무결성: 허가받지 않은 사람이 자료에 접근할 수 없게 함
- 사용 용이성: 프로그램을 배우는 데 요구되는 노력 최소
- 유지 보수성: 프로그램의 오류를 발견하고 수정하는데 필요한 능력 최소화
- 이식성: 다른 환경으로 이전하는 데 요구되는 노력
- 재사용성: 소프트웨어 일부를 다른 시스템에서 재사용할 수 있는 능력

소프트웨어 3R: 역공학, 재공학, 재사용

> 04\. 인터페이스 구현 검증도구 중 아래에서 설명하는 것은?
> `서비스 호출`, `컴포넌트 재사용` 등 다양한 환경을 지원하는 테스트 프레임워크
> 각 테스트 대상 분산 환경에 데몬을 사용하여 테스트 대상 프로그램을 통해 테스트를 수행하고, 통합하여 자동화하는 검증도구
>1. xUnit
>2. STAF V
>3. FitNesse
>4. RubyNode
xUnit – 다양한 언어 지원
STAF - `서비스 호출`,`컴포넌트 재사용`
FitNesse - `웹 기반`
Watir - `Ruby` 기반
Selenium - `웹 어플리케이션` 테스트 프레임워크

>05\. EAI(Enterprise Application Integration)의 구축 유형으로 옳지 않은 것은? 
>1. Point-to-Point X
>2. Hub&Spoke
>3. Message Bus
>4. Tree V
EAI: 조직의 애플리케이션을 연결해 업무 프로세스 단순화 및 자동화
`정보 전달`, `연계`, `통합`을 가능하게 해주는 솔루션
구축유형
- Point-to-Point: 미들웨어 없이 1:1 방식으로 어플리케이션 연결
- hub-and-spoke: Hub를 미들웨어로, hub 한 개만 사용
- message-bus
- hybrid: message-bus와 hub-and-spoke 혼합

> 06\. 다음 트리를 `전위 순회(preorder traversal)`한 결과는?
>1. +*AB*CDE
>2. AB/C*D*E+
>3. A/B*C*D+E
>4. +**/ABCDE V

+**/ABCDE
중위였다면: A/B*C*D+E
후위였다면: AB/C*D*E+

> 07\. 인터페이스 보안을 위해 `네트워크 영역`에 적용될 수 있는 솔루션과 거리가 먼 것은?
>1. IPSec
>2. SMTP V
>3. SSL X
>4. S-HTTP

IPSec - IP패킷 보호하는 프레임워크
SSL – 인증서
S-HTTP – 메시지 암호화 프로토콜

SMTP – 메일 주고받을 때 사용하는 보안 프로그램

인터페이스 보안 기능 적용
- 네트워크 영역: 스니핑 방지, 네트워크 트래픽 암호화(IPSec, SSL, S-HTTP)
- 애플리케이션 영역: 코드상 보안 취약점 보완 (시큐어 코딩, 암호화)

IPSec
- 네트워크 계층에서 IP패킷을 보호하는 프로토콜 표준의 프레임워크
- IPv6에 기본 탑재
IPSec의 기능
- Confidentiality(기밀성)
- Integrity(무결성)
- Origin Authentication(송신자 인증)
- Anti-replay protection(재전송 공격 방어)
- Accesss control(패킷 접근 제어): SP 참고
- Limited Traffic Flow Confidentialilty(패킷 출발지/도착지 정보 암호화)

종류
- AH 프로토콜
- ESP 프로토콜
- IKE 프로토콜

>08\. 평가점수에 따른 성적부여는 다음 표와 같다. 이를 구현한 소프트웨어를 `경계값 분석 기법`으로 테스트 하고자 할 때, 다음 중 테스트 케이스의 입력 값으로 옳지 않은 것은?
>1. 59
>2. 80
>3. 90 V
>4. 101
|평가점수|성적|
|80~100|A|
|60~79|B|
|0~59|C|

경계값 분석 해봐야 하는 값: -1,0,1,58,59,60,61,78,79,80,81,99,100,101
경계값 분석: Blackbox Testing

> 09\. 반정규화(Denormalization) 유형 중 중복 테이블을 추가하는 방법에 해당하지 않는 것은?
>1. 빌드 테이블의 추가 V
>2. 집계 테이블의 추가
>3. 진행 테이블의 추가
>4. 특정 부분만을 포함하는 테이블의 추가

정규화: 개념설계(E-R다이어그램)->논리설계(정규화)->물리설계()
반정규화: 정규화 후, 성능개선을 위해 정규화를 역행
- 테이블 분할
- 수평 분할: 값을 기준으로 두 테이블로 분할
- 수직 분할: 테이블의 속성을 분할해 두 테이블로 분할
- 테이블 중복
- 통계 테이블 추가(집계 테이블 추가)
- 진행 테이블 추가
- 컬럼 중복
- 중복 컬럼추가
- 파생 컬럼추가

>10\. `ISO/IEC 9126`의 소프트웨어 품질 특성 중 기능성(Functionality)의 하위 특성으로 옳지 않은 것은?
>1. 학습성 V
>2. 적합성
>3. 정확성
>.4. 보안성

학습성 – 사용성 범위로 취급

ISO/IEX 9126 품질특성
- 기능성: 적합성, 정확성, 상호운영성, 보안성, 준수성
- 신뢰성: 성숙성, 결함허용성, 복구성
- 사용성: 이해성, 학습성, 운용성, 준수성
- 효율성: 시간반응성, 자원효율성, 준수성
- 유지보수성: 분석성, 변경성, 안정성, 시험성, 준수성
- 이식성: 적응성, 설치성, 공존성, 대체성, 준수성

>11\. 다음 `트리의 차수(degree)`와 `단말 노드(terminal node)`의 수는?
>1. 차수:4, 단말노드:4 X
>2. 차수:2, 단말노드:4 V
>3. 차수:4, 단말노드:8
>4. 차수:2, 단말노드:8

노드의 차수: 해당 노드의 자식 개수
트리의 차수: 트리 중 가장 자식노드가 많은 노드의 자식 개수
단말노드: 자식이 없는 노드 개수

>12. `디지털 저작권 관리(DRM)`의 기술 요소가 아닌 것은>
>1. 크랙 방지 기술
>2. 정책 관리 기술
>3. 암호화 기술
>4. 방화벽 기술 V

방화벽 기술 – 보안 문제랑 더 관련있음(누군가는 쓰게 해주기 VS 다 못쓰게 하기)

DRM
|NAME|CONTENT|
|---|---|
|암호화|콘텐츠 및 라이선스 암호화|
|키관리|콘텐츠를 암호화한 키에 대한 저장 및 배포|
|식별기술|콘텐츠에 대한 식별체계 표현 기술|
|저작권 표현|라이선스의 내용 표현 기술|
|정책 관리|라이선스 발급 및 사용에 대한 정책표현|
|크랙 방지|크랙에 의한 콘텐츠 사용방지 기술|
|인증|라이선스 발급 및 사용의 기준이 되는 인증 기술|
|인터페이스|상이한 DRM 플랫폼 간의 상호 호환성 인터페이스|
|사용권한|콘텐츠의 사용에 대한 권한을 관리하는 기술|

>13\. 소프트웨어 테스트에서 `오류의 80%는 전체 모듈의 20% 내에서 발견`된다는 법칙은?
>1. Brooks의 법칙 V
>2. Boehm의 법칙
>3. Pareto의 법칙
>4. Jackson의 법칙

Pareto의 법칙: 소프트웨어 테스트에서 오류의 80%는 전체 모듈의 20% 내에서 발견됨
Brooks의 법칙: 지연되는 프로젝트에 인력을 투입하면 오히려 늦어진다.
Boehm의 법칙(업적): 비용산정기법, 나선형모델

>14\. `소프트웨어 형상 관리`의 의미로 적절한 것은?
>1. 비용에 관한 사항을 효율적으로 관리하는 것
>2. 개발 과정의 변경 사항을 관리하는 것 V
>3. 테스트 과정에서 소프트웨어를 통합하는 것 X
>4. 개발 인력을 관리하는 것

비용 – 초기에 정해진대로 고정
소프트웨어 통합 – 통합테스트
개발 인력 관리 – PM

소프트웨어 형상관리
소프트웨어 개발 과정에서 발생하는 모든 변경을 관리, 협업을 진행하는 멤버들의 공유 및 변경이력 관리
식별->통제->감사->기록
형상식별: 형상관리 대상 구분, 관리 목록에 대한 번호 부여
형상통제: sw 형상 변경 제안 검토, 변재 sw 기준선에 반영하도록 통제
형상감사: sw 베이스라인의 무결성 평가 수단
형상기록: sw 형상 및 변경 관리에 대한 각종 수행 기록

>15\. 알고리즘 `시간복잡도 O(1)`이 의미하는 것은?
>1. 컴퓨터 처리가 불가
>2. 알고리즘 입력 데이터 수가 한 개
>3. 알고리즘 수행시간이 입력 데이터 수와 관계없이 일정 V
>4. 알고리즘 길이가 입력 데이터보다 작음

>16\. 소스코드 품질분석 도구 중 `정적분석` 도구가 아닌 것은?
>1. Pmd
>2. Cppcheck
>3. valMeter V
>4. Checkstyle 

정적분석도구: 소스코드를 실행하지 않고 코딩 표준, 코딩 스타일, 구조, 의존관계 분석
- PMD, SonarQube, Find Bug, Checkstyle, cppcheck, corbertura

>17\. 검증 검사 기법 중 개발자의 장소에서 사용자가 개발자 앞에서 행하는 기법이며, 일반적으로 통제된 환경에서 `사용자와 개발자가 함께` 확인하면서 수행되는 검사는?
>1. 동치 분할 검사 X
>2. 형상 검사
>3. 알파 검사 V
>4. 베타 검사

V모델: 폭포수개발->단위테스트->통합테스트->시스템테스트->인수테스트
- 단위테스트: 모듈 당 테스트, 정적테스트/동적테스트
- 통합테스트: 시스템 통합해서 테스트, 상향식/하향식/빅뱅/백본 테스트
- 상향식: 하위모듈부터, 중간에 공백이 있으면 드라이버로 대체
- 하향식: 메인부터, 중간에 공백이 있으면 스텁으로 대체
- 빅뱅: 한번에 테스트 진행, 소규모여야 가능
- 백본: 상향식+하향식
- 시스템테스트: 실제로 운영되는 시스템 서버에서 테스트, 기능/비기능
- 기능: 소프트웨어의 기능/사용자의 요구사항 만족
- 비기능: 성능/보안
- 인수 테스트: 사용자가 진행, 알파/베타
- 알파: 사용자+개발자
- 베타: 사용자만

>18\. `하향식 통합`에 있어서 모듈 간의 통합 시험을 위해 일시적으로 필요한 조건만을 가지고 임시로 제공되는 `시험용 모듈`을 무엇이라고 하는가?
>1. Stub V
>2. Driver
>3. Procedure
>4. Function

Driver – 상향식

>19\. `SW 패키징 도구` 활용 시 고려 사항과 거리가 먼 것은?
>1. 패키징 시 사용자에게 배포되는 SW이므로 보안을 고려해야한다.
>2. 사용자 편의성을 위한 복합성 및 비효율성 문제를 고려해야한다. 
>3. 보안상 단일 기종에서만 사용할 수 있도록 해야 한다. V
>4. 제품 SW 종류에 적합한 암호화 알고리즘을 적용한다.

SW 패키징 도구 활용 시 고려사항
- 암호화/보안 고려
- 추가로 다양한 기종 연동 고려
- 사용자 편의성, 복잡성, 비효율성 고려
- 암호화 알고리즘 적용
- 지속적인 배포

>20\. `외계인코드(Alien Code)`에 대한 설명으로 옳은 것은?
>1. 프로그램의 로직이 복잡하여 이해하기 어려운 프로그램을 의미한다.
>2. 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 프로그램을 의미한다 V
>3. 오류가 없어 디버깅 과정이 필요없는 프로그램을 의미한다. X
>4. 사용자가 직접 작성한 프로그램을 의미한다. 

젤나가네(…)

스파게티 코드: 프로그램 로직이 복잡해서 이해하기 어려운 프로그램