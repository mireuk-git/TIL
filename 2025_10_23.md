# codekata
### 4757
[link](https://www.acmicpc.net/problem/4757)
#### python
```python
n=int(input())
winner=''
winner_point=[0,0]
for i in range(n):
    name,problem=input().split(" ",1)
    problem=list(map(int,problem.split()))
    solved,penalty=0,0
    for j in range(1,8,2):
        if problem[j]>0:
            solved+=1
            penalty+=problem[j]+(problem[j-1]-1)*20
    if winner=='' or winner_point[0] < solved or (winner_point[0] == solved and winner_point[1] > penalty):
        winner_point=[solved,penalty]
        winner = name
print(winner,winner_point[0],winner_point[1])
```
- `winner`, `winner_point`: 각각 승자 팀의 이름과 맞춘 개수, penalty point 관리
- `problem`: 이번 팀의 각 문제당 시도 횟수와 맞춘 시간 관리, `i=2*k`에 시도횟수, `i=2*k+1`에 맞춘 시간
- `solved`,`penalty`: 이번 팀의 맞춘 갯수와 penalty point, 승자 후보와 비교해 이번팀이 더 점수가 높으면 승자 후보를 이번 팀으로 덮어씌움

#### java
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class p4757 {
    public static void main(String[] args)throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        
        int n = Integer.parseInt(st.nextToken());
        String winner="";
        int winnerSolved=0 , winnerPenalty=0;
        for (int i=0;i<n;i++){
            st = new StringTokenizer(br.readLine());
            String name = st.nextToken();
            int solved=0, penalty=0;
            for (int j=0;j<4;j++){
                int tries = Integer.parseInt(st.nextToken());
                int time = Integer.parseInt(st.nextToken());
                if (time>0) {
                    solved++;
                    penalty+=time+(tries-1)*20;
                }
            }
            if (winnerSolved < solved || (winnerSolved == solved && winnerPenalty > penalty)){
                winner = name;
                winnerSolved = solved;
                winnerPenalty = penalty;
            }
        }
        System.out.println(winner+" "+winnerSolved+" "+winnerPenalty);
    }
}
```

# 정보처리기사
## 서브넷
#### 서브넷 계산
> 02\. 200.1.1.0 **/24** 네트워크를 FLSM 방식을 이용해 **10개의 subnet**으로 나누고 **ip subnet-zero**를 적용했다. 이때 서브네팅된 네트워크 중 **10번째 네트워크**의 **broadcast IP 주소**는?
>1. 200.1.1.159 V
>2. 201.1.5.175
>3. 202.1.11.191
>4. 203.1.255.245

서브넷 마스크: 200.1.1.128+64+32+16=240
첫번째 네트워크: 200.1.1.0 (IP subnet-zero)
11번째 네트워크: 200.1.1.0+16*10=160
10번째 네트워크의 브로드캐스트: 200.1.1.160-1=159

> 03\. 네트워크 주소가 **192.168.100.128**이며, **서브넷마스크가 '255.255.255.192'**인 네트워크가 있다. 이 네트워크에서 **사용 가능한 마지막 IP주소**는?
>1. 192.168.100.129
>2. 192.168.100.190 V
>3. 192.168.100.191
>4. 192.168.100.255

서브넷 마스크: 255.255.255.128+64
사용 가능한 마지막 IP 주소: 192.168.100.128+32+16+8+4+2=190
혹은 
다음 네트워크 주소: 192.168.100.128+64=192
그 이전 네트워크의 마지막 사용가능한 주소: 192.168.100.192-2=190

> 04\. 다음 조건일 때 사용되는 **브로드캐스트 주소**로 알맞은 것은?
>> IP주소: 192.168.3.157
>> 서브넷 마스크 값: 255.255.255.192
>1. 192.168.3.255
>2. 192.168.3.63
>3. 192.168.3.127
>4. 192.168.3.191 V

서브넷 마스크: 255.255.255.128+64
네트워크 주소: 192.168.3.128
브로드캐스트 주소: 192.168.3.128+64-1=191

> 05\. 네트워크 관리자인 A씨는 ISP로부터 100.100.100.0 **/24**를 할당받았다. 네트워크의 효율성을 위해 **최소 6개 서브넷**으로 분리하여 네트워크를 구성하되, 각 네트워크에는 **최소 20대 이상의 호스트**가 존재할 수 있도록 네트워크를 구성하고자 한다. 이때 사용해야하는 **서브넷 비트의 수**는 무엇인가?
>1. 25
>2. 26
>3. 27 V
>4. 28

2^3=8
24+3=27

#### 전송속도
bps: 데이터 전송 속도, 1초당 전송되는 비트 수
baud: 1초당 전송되는 신호의 수
PSK(위상) 변조방식: 2^k진일 때 단위신호가 kbit

> 01\. 데이터 변조속도가 **3600baud**이고 **쿼드비트**(Quad bit)를 사용하는 경우 **전송속도(bps)**는?
>1. 14400   V
>2. 10800
>3. 9600
>4. 7200

bps = 4(단위신호당 비트 수)*baud

> 02\. **4-PSK 변조방식**에서 변조 속도가 **1,200baud**일때, 데이터 전송속도는 몇 **bps**인가?
>1. 1200bps
>2. 2400bps V
>3. 3600bps
>4. 4800bps X

4-PSK 변조방식: 4방향 변조, 단위신호당 2bit 사용
1200*2=2400

> 03\. **8진 PSK 변조방식**에서 변조속도가 **2400baud**일때 정보신호의 전송속도(**bps**)는?
>1. 2400
>2. 4800
>3. 7200
>4. 9600

2400*3=7200 

> 04\. **9600bps**의 비트열을 **16진 psk**로 변조하여 전송하면 **변조속도**는?
>1. 1200baud
>2. 2400baud    V
>3. 3200baud
>4. 4600baud

9600/4=2400baud

