# 정보처리기사
## 소프트웨어 개발

#### 트리 운행
>01\. 다음 트리를 `preorder` 운행법으로 운행할 경우 가장 먼저 탐색되는 것은?
>1. A V
>2. B
>3. D X
>4. G

preorder - 전위순행 ↙→
inorder - 중위순행 ↗↘
postorder - 후위운행 →↖

전위순행 시 순서: A,B,D,C,E,G,H,F
중위순행 시 순서: D,B,A,G,E,H,C,F
후위순행 시 순서: D,B,G,H,E,F,C,A

#### 네트워크 보안
>02\. `인터페이스 보안`을 위해 네트워크 영역에 적용될 수 있는 솔루션과 거리가 `먼` 것은?
>1. IPSec
>2. SSL
>3. SMTP V
>4. S-HTTP

SMTP - 메일 프로토콜

인터페이스 보안 기능 적용
네트워크 영역
IPSec
- AH: 인증, 무결성
- ESP: 인증, 무결성, 기밀성(암호화)
SSL: 메시지 암호화
S-HTTP: 일부만 암호화

애플리케이션 영역
- 시큐어 코딩
- 암호화

#### 형상관리

>03\. 제품 소프트웨어의 `형상 관리` 역할로 틀린 것은?
>1. 형상관리를 통해 이전 리버전이나 버전에 대한 정보를 접근 가능하여 배포본 관리에 유용
>2. 불필요한 사용자의 소스 수정 제한
>3. 프로젝트 개발비용을 효율적으로 관리 V
>4. 동일한 프로젝트에 대해 여러 개발자 동시개발 가능 X

형상관리: 모든 산출물, 소스코드를 버전별로 관리
형상식별->형상통제->형상감사->형상기록
형상관리 도구: CVS, SVN, GIT

형상관리를 비용과는 관계없음

#### SW패키징 도구

>04\. 제품 소프트웨어 패키징 도구 활용시 고려사항이 아닌 것은?
>1. 제품 소프트웨어의 종류에 적합한 암호화 알고리즘을 고려한다. 
>2. 추가로 다양한 이기종 연동을 고려한다
>3. 사용자 편의성을 위한 복잡성 및 비효율성 문제를 고려한다.
>4. 내부 콘텐츠에 대한 보안은 고려하지 않는다. V

SW패키징 도구 활용 시 고려 사항
- 반드시 암호화/보안을 고려한다
- 추가로 다양한 이기종 연동을 고려한다
- 사용자 편의성을 위한 복잡성 및 비효율성 문제를 고려
- 애플리케이션의 종류에 적합한 암호화 알고리즘 적용
- 지속적인 배포 고려

#### 정렬법

>05\. 다음 자료에 대하여 선택(selection) 정렬을 이용하여 오름차순으로 정렬하고자 한다. 3회전 후의 결과로 옳은 것은?
> 37,14,17,40,35
>1. 14,17,37,40,35
>2. 14,37,17,40,35
>3. 17,14,37,35,40
>4. 14,17,35,40,37 v

0: 37,14,17,40,35
1: 14,37,17,40,35
2: 14,17,37,40,35
3: 14,17,35,40,37
4: 14,17,35,37,40

#### McCabe 순환복잡도

>06\. 제어흐름 그래프가 다음과 같을 때 McCabe의 cyclomatic 수는 얼마인가?
>1. 3 X
>2. 4 V
>3. 5
>4. 6

McCabe의 cyclomatic 수: 제어도의 면 수(뚫리지 않은 면 수) + 1

or

6-4+2=4

McCabe 순환 복잡도: 프로그램의 제어 흐름에 따라 복잡도 산정
계산식: v(g)=e(edge)-n(node)+2

#### 형상 관리
>07\. `형상관리도구`의 주요 기능으로 거리가 먼 것은?
>1. 정규화(Normalization) V
>2. 체크인(Check-in)
>3. 체크아웃(Check-out)
>4. 커밋(Commit)

정규화는 논리모델
형상관리와 관련이 없음

형상관리 용어
|`import`|맨 처음 프로젝트 시작시 저장소에 등록|
|`check-out`|저장소에서 소스를 찾아오는 명령|
|`check-in`(`commit`)|수정한 파일을 저장소에 저장해 갱신|
|`add`|새 파일을 관리 파일로 추가|
|`update`|저장소에 변경된 내용을 로컬로 반영|
|`diff`|소스를 비교하는 명령|
|`merging`|충돌된 파일을 합치는 작업|

#### 트리
>08\. 다음 트리의 `차수`(degree)는?
>1. 2
>2. 3 V
>3. 4
>4. 5

트리의 차수 = 자식이 가장 많은 노드의 자식 수
(BINARY TREE = 2진트리 = 차수:2)

#### 소프트웨어 테스트
>09\. 알파, 베타 테스트와 가장 밀접한 연관이 있는 테스트 단계는?
>1. 단위 테스트
>2. 인수 테스트 V
>3. 통합 테스트 X
>4. 시스템 테스트

폭포수 모델에서의 테스트 절차
단위 테스트(정적/동적) -> 통합 테스트(상향/하향/빅뱅/백본) -> 시스템 테스트(기능/비기능) -> 인수 테스트(알파/베타)

상향식 테스트에서 빈 모듈이 있으면 드라이버
하향식 테스트에선 스텁

#### 클린코드
>10\. 다음 중 클린 코드 작성 원칙으로 거리가 먼 것은?
>1. 누구든지 쉽게 이해하는 코드 작성
>2. `중복이 최대화`된 코드 작성 V
>3. 다른 모듈에 미치는 영향 최소화
>4. 단순, 명료한 코드 작성

외계인 코드: 오래전에 만들어져 개발자도 없는 코드 ~~젤나가 코드~~

클린코드 작성 원칙
- 가독성: 이해하기 쉬운 용어
- 단순성: 한번에 한가지 처리만 수행
- 의존성: 코드의 변경이 다른 부분에 영향이 없게 작성
- 중복성: 중복된 코드를 제거, 공통된 코드 사용
- 추상화: 상세 내용은 하위 클래스에서 구현

#### 저작권 관리(DRM)
>11\. 디지털 저작권 관리(DRM) 기술과 거리가 먼 것은?
>1. 콘텐츠 암호화 및 키 관리
>2. 콘텐츠 식별체계 표현
>3. 콘텐츠 오류 감지 및 복구 V
>4. 라이센스 발급 및 관리

DRM 기술 요소
- 암호화 및 키 관리
- 식별기술
- 저작권 표현
- 정책 관리
- 크랙 방지
- 인증
- 인터페이스
- 사용권한


#### 소프트웨어 재공학(Reengineering)
>12\. 소프트웨어 재공학이 소프트웨어의 재개발에 비해 갖는 장점으로 거리가 먼 것은?
>1. 위험부담 감소
>2. 비용 절감
>3. 시스템 명세의 오류 억제
>4. 개발 시간 증가 V

만든걸 고쳐쓰는데 다시 만드는거보다 시간이 늘어나면...

소프트웨어 재공학: 소프트웨어의 위기를 유지보수의 생산성으로 해결
- 분석(Analysis): 기존 소프트웨어를 분석해 재공학 대상 선정
- 재구성(Restructuring): 코드를 재구성해 기존 소프트웨어 향상
- 역공학(Reverse Engineering): 기존 소프트웨어를 분석해 소스코드 얻어냄
- 이식(Migration): 기존 소프트웨어를 다른 운영체제나 하드웨어 환경에서 사용할 수 있도록 변환
- 재사용

재공학 <-> 재개발(처음부터 다시 만들기)

#### 소프트웨어 품질 표준
>13\. 소프트웨어 품질 중 주어진 시간동안 주어진 기능을 오류없이 수행하는 정도를 나타낸 것은?
>1. 직관성
>2. 사용 용이성
>3. 신뢰성 V
>4. 이식성

IEEE 9126
- 기능성
- 신뢰성
- 사용성
- 효율성
- 유지보수성

소프트웨어 품질 표준 요소
- 정확성(요구사항 만족)
- 신뢰성(얼마나 장애 없이 잘 하는지)
- 사용용이성(배우기 쉬운지)
- 효율성(자원 얼마나 효율적으로 쓰는지)
- 유지보수성
- 이식성(MIGRATE)
- 무결성(함부로 내부사정 알려 하지 마세요)
- 재사용성(일부만 떼서 다른거 만드는데 쓸 수 있는지) 

#### 소프트웨어 공학의 기본 원칙
>14\. 소프트웨어 공학의 기본 원칙이라고 볼 수 없는 것은?
>1. 품질 높은 소프트웨어 상품 개발
>2. 지속적인 검증 시행
>3. 결과에 대한 명확한 기록 유지
>4. 최대한 많은 인력 투입 V

소프트웨어의 위기: 소프트웨어 개발 속도가 하드웨어 개발 속도를 따라가지 못해 사용자의 요구사항을 감당할 수 없음
- 프로젝트 개발 일정과 예산 측정 어려움
- 유지보수 비용 증가
- 소프트웨어 규모 증가와 복잡도에 따른 개발 비용 증가
- 프로젝트 관리 기술 부재
- 소프트웨어 개발 기술에 대한 훈련 부족

#### 인터페이스 구현
>15\. 인터페이스 구현 시 사용하는 기술 중 다음 내용이 설명하는 것은?
>`JavaScript`를 사용한 `비동기 통신기술`로 클라이언트와 서버 간에 XML 데이터를 주고 받는 기술
>1. procedure
>2. trigger
>3. greedy
>4. ajax V

AJAX - `JavaScript`, `비동기 통신기술`

#### 소프트웨어 테스트
>16\. 블랙박스 테스트의 유형으로 틀린 것은?
>1. 경계값 분석
>2. 오류 예측
>3. 동등 분할 기법
>4. 조건, 루프 검사 V

블랙박스 테스트는 내부코드 확인이 불가함
(오류 예측은 어떻게 하는거야)

black box test 기법
- 동등 분할 기법
- 경계값 분석 기법
- 오류 예측 기법
- 원인 결과 그래프 기법
- 의사결정 테이블 테스팅
- 상태 전이 테스팅

#### 국제표준
>17\. `패키지 소프트웨어`의 일반적인 `제품 품질 요구사항` 및 `테스트`를 위한 국제 표준은?
>1. ISO/IEC 2196 X
>2. IEEE 19554
>3. ISO/IEC 12119 V
>4. ISO/IEC 14959

#### 소프트웨어 테스트
>18\. 다음이 설명하는 애플리케이션 통합 테스트 유형은?
> 깊이 우선 방식 또는 너비 우선 방식이 있다.
> `상위 컴포넌트`를 테스트하고 `점증적으로 하위 컴포넌트`를 테스트한다.
>하위 컴포넌트 개발이 완료되지 않은 경우 `스텁(Stub)`을 사용하기도 한다.
>1. 하향식 통합 테스트 V
>2. 상향식 통합 테스트 
>3. 회귀 테스트
>4. 빅뱅 테스트

`스텁` - `하향`
`드라이버` - `상향`

#### 데이터베이스
>19\. 물리데이터 저장소의 파티션 설계에서 파티션 유형으로 옳지 않은 것은?
>1. 범위분할(Range Partitioning)
>2. 해시분할(Hash Partitioning)
>3. 조합분할(Composite Partitioning)
>4. 유닛분할(Unit Processing) V

파티션: 테이블 또는 인덱스 등을 나눈 단위
장점
- 데이터 엑세스 범위를 줄여 성능향상
- 파티션별로 데이터가 분산되어 디스크 성능 향상
- 파티션별 백업 및 복구 속도 향상
- 시스템 장애 시 데이터 손상정도 최소화
단점
- 하나의 테이블을 세분화하여 관리, 관리비용 증가
- 테이블간 조인에 대한 비용 증가

#### 알고리즘 설계 기법
>20\. 알고리즘 설계 기법으로 거리가 먼 것은?
>1. divide and conquer
>2. greedy
>3. static block V
>4. backtracking 

알고리즘 설계 기법
- 분할 정복법(divide and conquer): 병합정렬, 2진탐색
- 동적 계획법(dynamic programming): 플로이드
- 탐욕법(greedy): Dijkstra
- 백트래킹법(backtracking): DFS 알고리즘
- 근사해법(approximation): 최적해에 가까운 근사해