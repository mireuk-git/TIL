# 정보처리기사
## 데이터베이스 구축

#### 관계연산자
>01\. 다음 R과 S 두 릴레이션에 대한 division 연산의 수행 결과는?

R
|D1|D2|D3|
|---|---|---|
|a|1|A|
|b|1|A|
|a|2|A|
|c|2|B|

S
|D2|D3|
|---|---|
|1|A|

division
|D1|
|a|
|b|

division연산: S의 요소들이 모두 R에 포함되는 행에서, S의 속성들이 모두 빠짐

#### 정규화
>02\. 다음과 같이 위쪽 릴레이션을 아래쪽 릴레이션으로 정하였을 때 어떤 정규화 작업을 한 것인가?
>1. 제 1정규형 V 
>2. 제 2정규형 
>3. 제 3정규형 X
>4. 제 4정규형

|국가|도시|
|---|---|
|대한민국|서울, 부산|
|미국|워싱턴, 뉴욕|
|중국|베이징|
->
|국가|도시|
|---|---|
|대한민국|서울|
|대한민국|부산|

개념설계(E-R 다이어그램)->논리설계(정규화, 트랜잭션 인터페이스)->물리설계(반정규화)

정규화: 삽입이상, 삭제이상, 갱신이상을 회피하기 위해 진행
- 1차: 도메인이 원자값(도메인에 값 하나)
- 2차: 부분함수종속 제거(복합키의 일부 요소만으로 값이 검색된다면 부분함수종속)
- 3차: 이행적함수종속 제거(X->Y->Z를 X->Y, Y->Z로)
- BCNF: 결정자이면서 후보키가 아닌 것 제거(모두 후보키가 됨)
- 4차: 다치종속 제거
- 5차: 조인종속 제거(이용)

#### 투명성
>03\. 분산 데이터베이스의 투명성(Transparency)에 대해 해당하지 않는 것은?
>1. Location Transparency
>2. Replication Transparency
>3. Failure Transparency
>4. Media Access Transparency V

transparency: 사용자 입장에서의 알빠노
- 위치(location): 데이터가 어디에 있는지
- 중복(replication): 중복되어 저장된 값은 그중 하나가 업뎃되면 나머지도 알아서 업데이트
- 장애(failure): 오류가 나도 값을 검색가능함
- 분할(division): 데이터가 어떻게 분산되는지
- 병행(concurrency): 작업이 병행되는지 알빠노
- 지역사상(local mapping): 어느 위치에 있는지

#### 이상현상
>04\. 릴레이션 조작 시 `데이터들이 불필요하게 중복`되어 예기치 않게 발생하는 곤란한 현상을 의미하는 것은?
>1. normalization
>2. rollback
>3. cardinality X
>4. anomaly V

cardinality: 행
삽입이상, 갱신이상, 삭제이상 등의 원인이 됨

#### 데이터 모델
>05\. 다음 관계형 데이터 모델에 대한 설명으로 옳은 것은?
|고객ID|고객이름|거주도시|
|S1|홍길동|서울|
|S2|이정재|인천|
|S3|신보라|인천|
|S4|김흥국|서울|
|S5|도요새|용인|
>1. relation 3개, attribute 3개, tuple 5개
>2. relation 3개, attribute 5개, tuple 3개
>3. relation 1개, attribute 5개, tuple 3개
>4. relation 1개, attribute 3개, tuple 5개  V

relation: 테이블, 즉 위에서 relation은 하나

#### SQL
>06\. player 테이블에는 player_name, team_id, height 컬럼이 존재한다. 아래 sql문에서 문법적 오류가 있는 부분은?
```sql
(1) SELECT PLAYER_NAME, HEIGHT
(2) FROM PLAYER
(3) WHERE TEAM_ID = 'Korea'
(4) AND HEIGHT BETWEEN 170 OR 180;
```
>1. (1)
>2. (2)
>3. (3)
>4. (4) V

`BETWEEN`은 `AND`만 쓴다.

#### 정규화
>07\. 다음에 해당하는 함수종속의 추론규칙은?
> `X->Y이고 Y->Z이면 X->Z이다`
>1. 분해 규칙
>2. 이행 규칙 V
>3. 반사 규칙
>4. 결합 규칙

#### 무결성
>08\. 관계데이터 모델의 무결성 제약 중 기본키 값의 속성 값이 `널(NULL)값`이 아닌 원자 값을 갖는 성질은?
>1. 개체 무결성 V
>2. 참조 무결성
>3. 도메인 무결성 X
>4. 튜플의 유일성

무결성의 종류
- 도메인 무결성: 그 속성에 들어갈만한 값이 들어갔나
- 개체 무결성: 기본키 값 NULL X, 중복 X
- 참조 무결성: 외래키 값은 참조 릴레이션의 primal값과 동일
- 속성 무결성
- 키 무결성
- 사용자 정의 무결성

참조무결성 관련
- cascade: 지우면 참조하는 테이블에서도 지움
- restricted: 지울 수 없게 함

#### SQL
>09\. `DCL(Data Control Language)` 명령어가 아닌 것은?
>1. COMMIT
>2. ROLLBACK
>3. GRANT
>4. SELECT V

SQL언어
- DDL: CREATE, DROP, ALTER, RENAME, TRUNCATE
- DML: ADD, DELETE, UPDATE, SELECT
- DCL: COMMIT, ROLLBACK, GRANT, REVOKE

#### 테이블
>10\. 릴레이션에 대한 설명으로 거리가 먼 것은?
>1. 튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다.
>2. 한 릴레이션에 포함된 튜플들은 모두 상이하다.
>3. 애트리뷰트는 논리적으로 쪼갤 수 없는 원자값으로 저장한다.
>4. 한 릴레이션에 포함된 튜플 사이에는 `순서가 있다`. V

릴레이션 = 테이블
- 기본키가 존재하기 때문에 릴레이션 안의 튜플은 모두 상이함
- 1차 정규화를 거쳐서 원자값으로 저장

#### 정규화
>11\. 릴레이션 R의 `모든 결정자(determinant)가 후보키`이면, 그 릴레이션 R은 어떤 정규형에 속하는가?
>1. 제1정규형
>2. 제2정규형
>3. 보이스/코드 정규형 V
>4. 제4정규형

모든 결정자가 후보키 = 후보키가 아닌 결정자들은 모두 삭제당함 = BCNF

#### SQL
>12\. 관계 데이터베이스인 테이블 R1에 대한 아래 SQL문의 실행결과로 옳은 것은?
|학번|이름|학년|학과|주소|
|---|---|---|---|---|
|1000|홍길동|1|컴퓨터공학|서울|
|2000|김철수|1|전기공학|경기|
|3000|강남길|2|전자공학|경기|
|4000|오말자|2|컴퓨터|경기|
|5000|장미화|3|전자공학|서울|
```SQL
SELECT DISTINCT 학년 FROM R1;
```
|학년|
|---|
|1|
|2|
|3|

#### SQL
>13\. `DML(Data Manipulation Language)` 명령어가 아닌 것은?
>1. INSERT
>2. UPDATE
>3. ALTER V
>4. DELETE

DDL: CREATE, DROP, ALTER, TRUNCATE, RENAME
DML: SELECT, INSERT, DELETE, UPDATE
DCL: GRANT, REVOKE, COMMIT, ROLLBACK

#### 정규화
>14\. 정규화의 목적으로 옳지 않은 것은?
>1. 어떠한 릴레이션이라도 데이터베이스 내에서 표현 가능하게 만든다
>2. 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄인다.
>3. 중복을 배제하여 삽입, 삭제, 갱신 이상의 발생을 `야기`한다. V
>4. 효과적인 검색 알고리즘을 생성할 수 있다. 

삽입,삭제,갱신 이상 발생 억제

#### 트랜잭션
>15\. `commit`과 `rollback` 명령어에 의해 보장받는 트랜잭션의 특성은?
>1. 병행성
>2. 보안성
>3. 원자성 V
>4. 로그 X

트랜잭션의 특성
- 원자성(Atomicity): 모두 반영되거나 말거나
- 일관성(Consistency): 데이터가 일관성있게 유지
- 독립성,격리성(Isolation): 트랜잭션이 동시에 진행될때 한쪽이 다른쪽에 영향을 미칠 수 없음
- 영속성(Durability): 장애가 발생해도 값이 영구히 유지될 것

#### 로킹
>16\. 병행제어 기법 중 로킹에 대한 설명으로 옳지 않은 것은?
>1. 로킹의 대상이 되는 객체의 크기를 로킹 단위라고 한다.
>2. 데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있다.
>3. 로킹의 단위가 작아지면 로킹 오버헤드가 증가한다.
>4. `로킹의 단위가 커지면` `데이터베이스 공유도가 증가`한다. V

로킹: 데이터베이스의 값 중 일부의 조회 및 수정을 금지함
로킹 증가 -> 공유도 감소 -> 오버헤드 감소

#### 관계대수 연산자
>17\. 관계대수의 `순수관계 연산자`가 아닌 것은?
>1. Select
>2. Cartesian Product V
>3. Division
>4. Project

|관계대수 연산자|종류|
|순수|SELECT(σ), PROJECT(π), JOIN(><), DIVISION(÷)|
|일반|∪, ∩,차집합(-), 카티션 프로덕트(×)| 

####  
>18\. 뷰(VIEW)의 장점이 아닌 것은?
>1. `뷰 자체로` 인덱스를 가짐 V
>2. 데이터 보안 용이 X
>3. 논리적 독립성 제공
>4. 사용자 데이터 관리 용이

논리적으로만 존재하는 VIEW에게 인덱스를 부여할 수 없음, ALTER로 수정 불가

개념 스키마/내부 스키마/외부 스키마 중 외부 스키마에 해당

스키마: DB내에 어떤 구조로 데이터가 저장되는가
- 외부 스키마: 외부에서 보이는 구조
- 개념 스키마: 데이터베이스 전체적으로 관리
- 내부 스키마: 물리적인 저장장치 입장에서 DB가 저장된 것을 기술

- 외부 스키마 - 논리적 독립성 - 개념 스키마
- 개념 스키마 - 물리적 독립성 - 내부 스키마

#### 회복 기법
>19\. `데이터베이스 로그(log)`를 필요로 하는 회복 기법은?
>1. 즉각 갱신 기법 V
>2. 대수적 코딩 방법
>3. 타임 스탬프 기법
>4. 폴딩 기법

회복기법
- 즉시 갱신 기법
  - 변경되는 내용을 `그때그때 바로` 데이터베이스에 적용
  - `log`에 저장해 장애 발생시 `log`의 내용을 토대로 회복, 
  - 장애 발생 시점에서 완료된 작업이라면 `Redo`,완료되지 못했다면 `Undo` 실행
- 지연 갱신 기법
  - `부분완료 될 때까지` 데이터베이스에 적용 x
  - 부분완료 되면 `log` 내용 토대로 데이터베이스에 적용
  - `Undo`없이 `Redo`만 수행
- 검사 시점 기법
  - 실행 중간에 `검사 시점(check point)`를 지정해 검사 시점까지 수행 후 완료된 내용을 데이터베이스에 적용
- shadow paging 기법
  - log 사용 x, 데이터베이스를 동일한 크기의 `페이지`로 나눠 각 페이지마다 `복사`하여 그림자 페이지 보관
  - 변경되는 내용은 원본에, 장애 발생시 그림자 페이지로 회복

####
>20\. 다음 중 SQL의 집계 함수(aggregation function)가 아닌 것은?
>1. AVG
>2. COUNT
>3. SUM
>4. CREATE V