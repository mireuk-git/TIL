# Codecata
### 14911
[link](https://www.acmicpc.net/problem/14911)
#### python
```python
l=list(map(int,input().split()))
n=int(input())
l.sort()

left,right = 0,len(l)-1
results=[]
results_set=set()
while left<right:
    sum=l[left]+l[right]
    if sum==n and (l[left],l[right]) not in results_set:
        results.append((l[left],l[right]))
        results_set.add((l[left],l[right]))
        left+=1
        right-=1
    elif sum<n: left+=1
    else: right-=1

for i in results:
    print(f"{i[0]} {i[1]}")
print(len(results))
```
- 사전 순 나열을 위해 입력된 수들을 미리 정렬
- 검색 결과는 순서 유지를 위해 `list`자료형을 사용, 빠른 중복 검색을 위해 hash를 사용하는 `set`을 별개로 운용
- `left`, `right`: l 내부를 순회하는 포인터
- 두 자연수의 합이 n보다 작으면 합이 더 커지는 방향으로 포인터 이동(`left+=1`)
- 두 자연수의 합이 n보다 크면 합이 더 작아지는 방향으로 포인터 이동(`right-=1`)
- 종료 조건: `left>=right`

#### java
- `HashSet<Integer[]>`는 내부 요소의 중복을 거르지 못한다: 배열이 객체라 메모리 주소 값으로 판정하기 때문에 두 배열에 같은 요소가 들어갔더라도 메모리값이 다르기 때문에 둘다 `HashSet`에 존재하며, 중복을 제거할 수 없다

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.StringTokenizer;

class p14911{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        StringTokenizer st = new StringTokenizer(br.readLine());
        List<Integer> l = new ArrayList<>();
        while (st.hasMoreTokens()) {
            l.add(Integer.parseInt(st.nextToken()));
            
        }
        st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        l.sort(Comparator.naturalOrder());

        int left=0, right=l.size()-1;
        List<Integer[]> results = new ArrayList<>();
        while (left<right){
            int sum = l.get(left)+l.get(right);
            if (sum == n){
                Integer[] result = {l.get(left),l.get(right)};
                results.add(result);
                while (left < right && l.get(left).equals(result[0])) left++;
                while (left <right && l.get(right).equals(result[1])) right--;
            }
            else if (sum < n) left++;
            else right--;
        }

        for (Integer[] result : results){
            System.out.println(result[0]+" "+result[1]);
        }
        System.out.println(results.size());
    }
}
```
- `HashSet`을 사용하지 않고 투 포인터를 중복을 피하게 움직이게 구현했다.