# Codekata
### 16218
[link](https://www.acmicpc.net/problem/16218)
#### python
```python
import sys
input=sys.stdin.readline

n,k=map(int,input().strip().split())
cummulate_a,cummulate_b=0,0
rebound=0
gg_flag=False
winner=0
overpowered=False

def overpower(a,b):
    global cummulate_a, cummulate_b, k, overpowered
    if overpowered: return False
    if cummulate_a + (int)(1.5*a) >= cummulate_b + b + 50:
        return True
    if cummulate_a + (int)(1.5*a) >= k and cummulate_b + b < k:
        return True
    else: return False

for i in range(n):
    line = input().strip()
    if not line: continue
    a, b = map(int, line.split())
    if gg_flag: continue

    cummulate_a-=rebound
    rebound=0
    if overpower(a,b): 
        rebound = (int)(a*1.5)-a
        a = (int)(a*1.5)
        overpowered=True
    cummulate_a+=a
    cummulate_b+=b
    
    if cummulate_a >= k and cummulate_b >= k:
        gg_flag=True
        if overpowered: winner = -1
        else: winner = 1
    if cummulate_a>=k or cummulate_a-cummulate_b>=50:
        winner = 1
        gg_flag = True
    elif cummulate_b>=k:
        winner = -1
        gg_flag = True

print(winner)
```
- 중간에 예제 그지같은거 먹여놨나보네h dlEkrnfh aksemfdjshgdmffo wlsWk?
- 중간에 멋대로 끝나버리는 예제 하나가 있어서 EOF 처리를 위해 `if not line: continue` 파츠가 반드시 있어야 한다. 이거 찾으려고 한시간 걸렸다. 
- 본문에서 메모리 사용에 주의를 줬기 때문에 배열을 사용하지 않는 방법으로 코드 작성
- `cummulate_a`,`cummulate_b`: 입력으로 주어지는 `a`,`b`의 누적합
- `rebound`: 이전 턴에 OP를 썼다면 즉시 추가되는 만큼 반동 저장, 그 다음 턴에 추가된 반동만큼 `a`의 누적합에서 차감하고 0으로 재설정. 이후 `overpowered`로 OP의 중복을 방지하기에 다시 쓸 일 없음
- `overpowered`: OP를 사용했다면 즉시 참, 이후 OP를 다시 사용할 수 없게 방지하고 승패에 영향을 미침
- `gg_flag`: 만약 `n`라운드 전에 승패가 갈린다면 즉시 참이 되고, 이후 전개는 입력만 받고 무시함
- `overpower(a,b)`: 이번턴의 `a`와 `b`를 입력받아 이번턴에 OP를 사용할건지 말건지 결정
- OP의 사용조건: 이번턴에 한판승을 낼 수 있는지, 이번턴에 OP를 쓰면 상대를 타격할 수 있으면서 동시에 타격받지 않는지
- `EOF`를 `sys.stdin.readline`으로 읽으면 `''`(빈 문자열)이 반환된다. `while`등으로 계속 읽어도 `EOF`만 읽힌다.
- `ValueError`가 발생할 때는 입력이 제대로 들어오는지 확인할 것(EOF가 들어오는지, 예상했던 것과 다른 예제가 들어오는지)