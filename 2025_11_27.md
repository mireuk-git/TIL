# Codekata
### 16218
[link](https://www.acmicpc.net/problem/16218)
#### python
```python
import sys
input=sys.stdin.readline

n,k=map(int,input().strip().split())
cummulate_a,cummulate_b=0,0
rebound=0
gg_flag=False
winner=0
overpowered=False

def overpower(a,b):
    global cummulate_a, cummulate_b, k, overpowered
    if overpowered: return False
    if cummulate_a + (int)(1.5*a) >= cummulate_b + b + 50:
        return True
    if cummulate_a + (int)(1.5*a) >= k and cummulate_b + b < k:
        return True
    else: return False

for i in range(n):
    line = input().strip()
    if not line: continue
    a, b = map(int, line.split())
    if gg_flag: continue

    cummulate_a-=rebound
    rebound=0
    if overpower(a,b): 
        rebound = (int)(a*1.5)-a
        a = (int)(a*1.5)
        overpowered=True
    cummulate_a+=a
    cummulate_b+=b
    
    if cummulate_a >= k and cummulate_b >= k:
        gg_flag=True
        if overpowered: winner = -1
        else: winner = 1
    if cummulate_a>=k or cummulate_a-cummulate_b>=50:
        winner = 1
        gg_flag = True
    elif cummulate_b>=k:
        winner = -1
        gg_flag = True

print(winner)
```
- 중간에 예제 그지같은거 먹여놨나보네h dlEkrnfh aksemfdjshgdmffo wlsWk?
- 중간에 멋대로 끝나버리는 예제 하나가 있어서 EOF 처리를 위해 `if not line: continue` 파츠가 반드시 있어야 한다. 이거 찾으려고 한시간 걸렸다. 
- 본문에서 메모리 사용에 주의를 줬기 때문에 배열을 사용하지 않는 방법으로 코드 작성
- `cummulate_a`,`cummulate_b`: 입력으로 주어지는 `a`,`b`의 누적합
- `rebound`: 이전 턴에 OP를 썼다면 즉시 추가되는 만큼 반동 저장, 그 다음 턴에 추가된 반동만큼 `a`의 누적합에서 차감하고 0으로 재설정. 이후 `overpowered`로 OP의 중복을 방지하기에 다시 쓸 일 없음
- `overpowered`: OP를 사용했다면 즉시 참, 이후 OP를 다시 사용할 수 없게 방지하고 승패에 영향을 미침
- `gg_flag`: 만약 `n`라운드 전에 승패가 갈린다면 즉시 참이 되고, 이후 전개는 입력만 받고 무시함
- `overpower(a,b)`: 이번턴의 `a`와 `b`를 입력받아 이번턴에 OP를 사용할건지 말건지 결정
- OP의 사용조건: 이번턴에 한판승을 낼 수 있는지, 이번턴에 OP를 쓰면 상대를 타격할 수 있으면서 동시에 타격받지 않는지
- `EOF`를 `sys.stdin.readline`으로 읽으면 `''`(빈 문자열)이 반환된다. `while`등으로 계속 읽어도 `EOF`만 읽힌다.
- `ValueError`가 발생할 때는 입력이 제대로 들어오는지 확인할 것(EOF가 들어오는지, 예상했던 것과 다른 예제가 들어오는지)

# 정보처리기사
## 디스크 스케줄링
#### SSTF(Shortest Seek Time First)

> 02\. 디스크 큐에 다음과 같이 I/O 요청이 들어와 있다. `최소탐색시간 우선(SSTF)` 스케줄링 적용 시 발생하는 총 헤드 `이동 거리`를 구하시오. (단, 추가 I/O 요청은 없다고 가정한다. 디스크 헤드는 0부터 150까지 이동 가능하며, `현재 위치는 50`이다.)
> 대기큐: 80,20,100,30,70,130,40

정렬: 20 30 40 70 80 100 130
50 > 40 > 30 > 20 > 70 > 80 > 100 > 130
10+10+10+50+10+20+30 = 140

> 03\. 사용자가 요청한 디스크 입출력 내용이 다음과 같은 순서로 큐에 들어 있을 때 `SSTF 스케줄링`을 사용한 경우의 `처리 순서`를 쓰시오.(단, `현재 헤드 위치는 53`이고, 제일 안쪽이 1번, 바깥쪽이 200번 트랙이다.)
> 대기큐: 98,183,37,122,14,124,65,67

정렬: 14,37,65,67,98,122,124,183
53 > 65 > 67 > 37 > 14 > 98 > 122 > 124 > 183
처리순서 기입할 때 시작점 반드시 써야함