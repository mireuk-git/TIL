# CodeKata
### python
#### 27952
[link](https://www.acmicpc.net/problem/27952)
<b>1st try:</b>

```python
n,x=map(int,input().split())
a=list(map(int,input().split()))
b=list(map(int,input().split()))
w,count=0,0
for i in range(n):
    w+=b[i]
    while w-x>a[i]:
        w-=x
        count+=1
    if w<a[i]:
        count=-1
        break
print(count)
```
- `w`: 현재 몸무게 관리, 몸무게 누적 변화량
- 쓰러지지 않을 때까지 그리디 알고리즘으로 루틴횟수를 최대로
- `b[i]`가 적어 건표가 쓰러질때 다시 플랜짜는 기능은 미탑재

<b>2nd try:</b>

```python
n,x=map(int,input().split())
a=list(map(int,input().split()))
b=list(map(int,input().split()))
count,w=0,0
for i in range(n):
    w+=b[i]
    while count>0 and w<a[i]:
        count-=1
        w+=x
    while w-x>=a[i]:
        w-=x
        count+=1
    if w<a[i]:
        count=-1
        break
print(count)
```
- 그리디로 `count`를 최대로 유지하다 건표가 쓰러진다면 `count`를 -1하고 `w`를 `x`만큼 더해 루틴반복횟수를 1개 덜한 상태로 되돌린다, `w`가 충분해질 때까지 반복한다
- 방법은 이제 어느정도 맞는거 같은데 부분제한으로 `(1<=n<=5000)`일때까지만 맞았다. 다음조건은 `(1<=A[i],b[i],x<=100, 1<=n<=500000)`인데 계산속도 최적화를 노려봐야 할 듯 하다

<b>3rd try:</b>

```python
import sys
input=sys.stdin.readline

n,x=map(int,input().split())
a=list(map(int,input().split()))
b=list(map(int,input().split()))
count,w=0,0
for i in range(n):
    w+=b[i]
    if w<a[i] and count>0:
        tmp=min((a[i]-w+x-1)//x,count)
        count-=tmp
        w+=tmp*x
    if w>=a[i]:
        tmp=(w-a[i])//x
        w-=tmp*x
        count+=tmp
    if w<a[i]:
        count=-1
        break
print(count)
```
- while 반복문 대신 산술연산으로 계산과정을 최적화
- +x-1을 해서 x로 나눌 때의 올림나눗셈을 진행할 수 있다. 
- 입력속도와 계산속도를 손보고 나니 성공했다. 
