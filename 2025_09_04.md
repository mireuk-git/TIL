# CodeKata
### python
#### 14534
[link](https://www.acmicpc.net/problem/14534)
```python
from itertools import permutations
t=int(input())
for test_case in range(1,t+1):
    l=input()
    p=permutations(l)
    print(f"Case # {test_case}:")
    for i in p:
        r=''
        for j in i:
            r+=j
        print(r)
```
- `permutations`를 import해와 간편하게 순열을 만들 수 있다. 
- 다만 이 경우 결과값으로 tuple이 반환되기 때문에 tuple에서 다시 글자 하나하나씩 가져와 출력해야 의도한 결과를 만들 수 있다. 

#### 13360
[link](https://www.acmicpc.net/problem/13360)
```python
match=input()
rank=25
star=0
required_star=[-1,5,5,4,3,2]
streak=0
for i in match:
    if i=='W':
        streak+=1
        if rank>=6 and streak>2: star+=2
        else: star+=1
        
        if star>required_star[(rank+4)//5]:
            star-=required_star[(rank+4)//5]
            rank-=1
            if rank==0: 
                rank='Legend'
                break
    
    else: 
        streak=0
        if rank<20: 
            star-=1
            if star<0: 
                rank+=1
                star=required_star[(rank+4)//5]-1
        elif rank==20 and star>0: star-=1
print(rank)
```
- 조건이 그지같고 복잡하지만 하란것만 잘 구현하면 된다. 

#### 28256
[link](https://www.acmicpc.net/problem/28256)
```python
def visit(x,y):
    if x<0 or x>2 or y<0 or y>2 or visited[x][y]: return 0
    visited[x][y]=True
    if chocolate[x][y]=='O':
        return 1+visit(x+1,y)+visit(x-1,y)+visit(x,y+1)+visit(x,y-1)
    else: return 0

t=int(input())
for test_case in range(1,t+1):
    chocolate=[list(input()) for _ in range(3)]
    a=list(map(int,input().split()))
    n=a[0]
    visited=[[False,False,False],[False,True,False],[False,False,False]]
    r=['']
    for i in range(3):
        for j in range(3):
            tmp=visit(i,j)
            if tmp>0:
                r.append(tmp)
    r.sort()

    flag=1
    if len(r)-1==n:
        for i in range(1,n+1):
            if a[i]!=r[i]:
                flag=0
                break
    else: flag=0
    print(flag)
```
- dfs 탐색으로 상자 그래프 `chocolate`를 탐색, 인접한 좌표에 'O'가 입력되어있다면 한 청크로 묶어서 계산
- `visited`: 방문한 노드를 저장하는 용도의 그래프, 초기값은 모두 False로 되어있으나 가운데 노드는 True, 어차피 값이 `'-'`로 `'O'`가 포함될 수 없음이 확정되어있기에 방문하지 않아도 됨
- `chocolate`그래프의 모든 노드에서 방문시도해 인접한 초콜릿 개수를 `r`에 저장, 이미 방문한 노드거나 `'X'`라면 `r`에 추가하지 않음
- 모든 청크의 초콜릿 개수를 저장했다면 `r`과 `a`의 각 요소에 대해 비교, `a[0]`은 `n`이므로 `r[0]`에 빈값을 넣고 `i=1`부터 비교
- 이때 `r`의 개수와 `a`의 개수가 같지 않을수 있으므로 `len(r)-1`과 `a`의 개수 `n`이 같은지 먼저 확인해야한다. 같지 않다면 `0`을 띄운다. 
